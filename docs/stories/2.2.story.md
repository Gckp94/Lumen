# Story 2.2: Bounds Filtering

## Status

Done

## Story

**As a** user,
**I want** to filter data by value ranges,
**so that** I can focus on specific subsets of my trades.

## Acceptance Criteria

1. "Add Filter" button with filter row (column, operator, min, max, remove)
2. Operators: "between", "not between"
3. Filter validation (min ≤ max, numeric values)
4. "Apply Filters" updates chart and row count
5. Applied filters shown as styled chips (nova-amber)
6. "Clear All Filters" resets to baseline
7. Filter applied in < 500ms for 100k rows

## Tasks / Subtasks

- [x] Task 0: Add Limits Class to Constants (Prerequisite)
  - [x] Add `Limits` class to `src/ui/constants.py`
  - [x] Define `MAX_FILTERS = 10`
  - [x] Define `MIN_WINDOW_WIDTH = 1280`
  - [x] Define `MIN_WINDOW_HEIGHT = 720`
  - [x] Define `MAX_RECENT_FILES = 10`
  - [x] Define `CACHE_MAX_AGE_DAYS = 30`

- [x] Task 1: Create FilterCriteria Model (AC: 2, 3)
  - [x] Add `FilterCriteria` dataclass to `src/core/models.py`
  - [x] Implement `column: str`, `operator: Literal["between", "not_between"]`, `min_val: float`, `max_val: float`
  - [x] Implement `validate() -> str | None` method that returns error if min_val > max_val
  - [x] Implement `apply(df: pd.DataFrame) -> pd.Series` method returning boolean mask
  - [x] Add type hints and docstrings per coding standards

- [x] Task 2: Create FilterEngine Core Logic (AC: 4, 7)
  - [x] Create `src/core/filter_engine.py` with `FilterEngine` class
  - [x] Implement `apply_filters(df: pd.DataFrame, filters: list[FilterCriteria]) -> pd.DataFrame`
  - [x] Implement AND logic: all filters must pass
  - [x] Return explicit copy of filtered DataFrame (`df[mask].copy()`)
  - [x] Add logging for filter operations
  - [x] Export `FilterEngine` from `src/core/__init__.py`

- [x] Task 3: Create FilterChip Component (AC: 5, 6)
  - [x] Create `src/ui/components/filter_chip.py` with `FilterChip` class
  - [x] Inherit from `QFrame` for styling
  - [x] Display filter summary: "{column} {operator} {min}-{max}"
  - [x] Add remove button (✕) with `removed = Signal(FilterCriteria)`
  - [x] Style with nova-amber (`Colors.SIGNAL_AMBER`) background
  - [x] Add hover effect for remove button
  - [x] Export `FilterChip` from `src/ui/components/__init__.py`

- [x] Task 4: Create FilterRow Component (AC: 1, 2, 3)
  - [x] Create `src/ui/components/filter_row.py` with `FilterRow` class
  - [x] Column dropdown: `QComboBox` populated with numeric columns
  - [x] Operator dropdown: `QComboBox` with "between", "not between"
  - [x] Min/Max inputs: `QLineEdit` with float validation
  - [x] Remove button: `QPushButton` with ✕ icon
  - [x] Signal `filter_changed = Signal(FilterCriteria | None)` - emits None on remove
  - [x] Signal `validation_failed = Signal(str)` for error display
  - [x] Implement `get_criteria() -> FilterCriteria | None` method
  - [x] Style inputs with Observatory theme
  - [x] Export `FilterRow` from `src/ui/components/__init__.py`

- [x] Task 5: Create FilterPanel Container (AC: 1, 4, 5, 6)
  - [x] Create `src/ui/components/filter_panel.py` with `FilterPanel` class
  - [x] "Add Filter" button at top
  - [x] Container for `FilterRow` widgets (max 10 filters per `Limits.MAX_FILTERS`)
  - [x] "Apply Filters" button (primary action style)
  - [x] "Clear All Filters" button (secondary style)
  - [x] Chips area: `QHBoxLayout` for active `FilterChip` widgets
  - [x] Signal `filters_applied = Signal(list)` - emits list[FilterCriteria]
  - [x] Signal `filters_cleared = Signal()`
  - [x] Populate column dropdown from numeric columns
  - [x] Export `FilterPanel` from `src/ui/components/__init__.py`

- [x] Task 6: Integrate FilterPanel into Feature Explorer (AC: 1, 4, 5)
  - [x] Import `FilterPanel` into `src/tabs/feature_explorer.py`
  - [x] Add `FilterPanel` to sidebar below column selector
  - [x] Connect `filters_applied` signal to new `_on_filters_applied` method
  - [x] Connect `filters_cleared` signal to new `_on_filters_cleared` method
  - [x] Pass numeric columns to FilterPanel when data loads

- [x] Task 7: Connect to AppState (AC: 4, 6)
  - [x] In `_on_filters_applied`: store filters in `AppState.filters`
  - [x] In `_on_filters_applied`: use `FilterEngine` to filter `baseline_df`
  - [x] In `_on_filters_applied`: store result in `AppState.filtered_df`
  - [x] In `_on_filters_applied`: emit `filtered_data_updated` signal
  - [x] In `_on_filters_cleared`: clear `AppState.filters` list
  - [x] In `_on_filters_cleared`: reset `AppState.filtered_df` to `baseline_df`
  - [x] In `_on_filters_cleared`: emit `filtered_data_updated` signal

- [x] Task 8: Update Chart Display (AC: 4)
  - [x] Connect to `filtered_data_updated` signal in Feature Explorer
  - [x] When filters applied, update chart with `filtered_df`
  - [x] When filters cleared, update chart with `baseline_df`
  - [x] Update bottom bar count to show filtered data point count

- [x] Task 9: Write Unit Tests for FilterCriteria (AC: 2, 3)
  - [x] Create `tests/unit/test_filter_criteria.py`
  - [x] Test `between` operator creates correct mask
  - [x] Test `not_between` operator creates correct mask
  - [x] Test boundary values are inclusive for `between`
  - [x] Test `validate()` returns error when min > max
  - [x] Test `validate()` returns None for valid criteria

- [x] Task 10: Write Unit Tests for FilterEngine (AC: 4, 7)
  - [x] Create `tests/unit/test_filter_engine.py`
  - [x] Test single filter application
  - [x] Test multiple filters with AND logic
  - [x] Test empty filter list returns original DataFrame
  - [x] Test returns copy (not view) of DataFrame

- [x] Task 11: Write Widget Tests for FilterChip (AC: 5)
  - [x] Create `tests/widget/test_filter_chip.py`
  - [x] Test chip displays filter summary correctly
  - [x] Test remove button emits `removed` signal with criteria
  - [x] Test chip styled with amber background

- [x] Task 12: Write Widget Tests for FilterPanel (AC: 1, 5, 6)
  - [x] Create `tests/widget/test_filter_panel.py`
  - [x] Test "Add Filter" creates new FilterRow
  - [x] Test "Apply Filters" emits `filters_applied` with criteria list
  - [x] Test "Clear All Filters" removes all rows and emits signal
  - [x] Test chips appear after filter applied

- [x] Task 13: Write Integration Test for Filter Workflow (AC: 4)
  - [x] Add test to `tests/integration/test_filter_workflow.py`
  - [x] Test: load data → add filter → apply → verify chart updates
  - [x] Test: apply filters → clear → verify baseline restored

- [x] Task 14: Write Performance Test (AC: 7)
  - [x] Add test to `tests/integration/test_performance.py`
  - [x] Test filter application < 500ms for 100k rows
  - [x] Mark with `@pytest.mark.slow`

- [x] Task 15: Manual Verification (AC: 1-7)
  - [x] Run `make lint` and fix any issues
  - [x] Run `make typecheck` and fix any issues
  - [x] Run `make test` and verify all tests pass

## Dev Notes

### Previous Story Insights
[Source: Story 2.1 Dev Agent Record]

- `FeatureExplorerTab` fully implemented at `src/tabs/feature_explorer.py` with:
  - 3-panel layout: sidebar (25%), chart (75%), bottom bar
  - `_column_selector: QComboBox` for column selection
  - `_chart_canvas: ChartCanvas` for PyQtGraph scatter plot
  - `_data_count_label: QLabel` in bottom bar
  - Connected to `data_loaded` and `baseline_calculated` signals
  - Has `_get_numeric_columns(df)` helper method
- `ChartCanvas` component at `src/ui/components/chart_canvas.py` with `update_data()` method
- `AppState` has `filters: list[object]` ready (typed as `list[FilterCriteria]` after this story)
- `AppState` signals ready: `filters_changed`, `filtered_data_updated`

### FilterCriteria Model Specification
[Source: architecture/4-data-models.md#FilterCriteria]

```python
# Add to src/core/models.py
from typing import Literal

@dataclass
class FilterCriteria:
    """Single filter criterion for bounds-based filtering."""

    column: str
    operator: Literal["between", "not_between"]
    min_val: float
    max_val: float

    def validate(self) -> str | None:
        """Validate filter. Returns error message or None if valid."""
        if self.min_val > self.max_val:
            return "Min value must be less than max value"
        return None

    def apply(self, df: pd.DataFrame) -> pd.Series:
        """Return boolean mask for this filter."""
        col = df[self.column]
        if self.operator == "between":
            return (col >= self.min_val) & (col <= self.max_val)
        else:  # not_between
            return (col < self.min_val) | (col > self.max_val)
```

### FilterEngine Specification
[Source: architecture/5-components.md#FilterEngine]

```python
# src/core/filter_engine.py
import logging
import pandas as pd
from .models import FilterCriteria

logger = logging.getLogger(__name__)

class FilterEngine:
    """Apply bounds-based filters to DataFrames."""

    def apply_filters(
        self,
        df: pd.DataFrame,
        filters: list[FilterCriteria],
    ) -> pd.DataFrame:
        """Apply all filters with AND logic.
        
        Args:
            df: Source DataFrame to filter.
            filters: List of filter criteria to apply.
            
        Returns:
            Filtered DataFrame (copy, not view).
        """
        if not filters:
            return df.copy()
        
        mask = pd.Series(True, index=df.index)
        for criteria in filters:
            mask &= criteria.apply(df)
            
        logger.debug("Filter mask: %d rows match out of %d", mask.sum(), len(df))
        return df[mask].copy()
```

### FilterChip Component Specification
[Source: architecture/5-components.md#FilterChip]

```python
# src/ui/components/filter_chip.py
from PyQt6.QtCore import pyqtSignal
from PyQt6.QtWidgets import QFrame, QHBoxLayout, QLabel, QPushButton
from src.core.models import FilterCriteria
from src.ui.constants import Colors, Spacing

class FilterChip(QFrame):
    """Display active filter with remove action."""

    removed = pyqtSignal(object)  # FilterCriteria

    def __init__(
        self,
        criteria: FilterCriteria,
        parent: QWidget | None = None,
    ) -> None:
        super().__init__(parent)
        self._criteria = criteria
        self._setup_ui()
        self._apply_style()

    def _setup_ui(self) -> None:
        layout = QHBoxLayout(self)
        layout.setContentsMargins(Spacing.SM, Spacing.XS, Spacing.SM, Spacing.XS)
        
        # Filter summary label
        op_text = "between" if self._criteria.operator == "between" else "not between"
        text = f"{self._criteria.column} {op_text} {self._criteria.min_val}-{self._criteria.max_val}"
        self._label = QLabel(text)
        layout.addWidget(self._label)
        
        # Remove button
        self._remove_btn = QPushButton("✕")
        self._remove_btn.clicked.connect(self._on_remove)
        layout.addWidget(self._remove_btn)

    def _apply_style(self) -> None:
        self.setStyleSheet(f"""
            FilterChip {{
                background-color: {Colors.SIGNAL_AMBER};
                border-radius: 4px;
            }}
            QLabel {{
                color: {Colors.BG_BASE};
                font-weight: bold;
            }}
            QPushButton {{
                background: transparent;
                border: none;
                color: {Colors.BG_BASE};
                padding: 0 4px;
            }}
            QPushButton:hover {{
                color: {Colors.SIGNAL_CORAL};
            }}
        """)

    def _on_remove(self) -> None:
        self.removed.emit(self._criteria)
```

### File Locations
[Source: architecture/2-high-level-architecture.md#repository-structure]

| File | Purpose |
|------|---------|
| `src/core/models.py` | Add FilterCriteria dataclass (MODIFY) |
| `src/core/filter_engine.py` | FilterEngine class (NEW) |
| `src/core/__init__.py` | Export FilterEngine (MODIFY) |
| `src/ui/components/filter_chip.py` | FilterChip component (NEW) |
| `src/ui/components/filter_row.py` | FilterRow input component (NEW) |
| `src/ui/components/filter_panel.py` | FilterPanel container (NEW) |
| `src/ui/components/__init__.py` | Export new components (MODIFY) |
| `src/tabs/feature_explorer.py` | Integrate FilterPanel (MODIFY) |
| `tests/unit/test_filter_criteria.py` | FilterCriteria unit tests (NEW) |
| `tests/unit/test_filter_engine.py` | FilterEngine unit tests (NEW) |
| `tests/widget/test_filter_chip.py` | FilterChip widget tests (NEW) |
| `tests/widget/test_filter_panel.py` | FilterPanel widget tests (NEW) |
| `tests/integration/test_filter_workflow.py` | Filter workflow integration (NEW) |
| `tests/integration/test_performance.py` | Performance tests (MODIFY) |

### Theme Constants
[Source: architecture/9-coding-standards.md#Theme Constants]

```python
# src/ui/constants.py - already defined
class Colors:
    # Signal Colors
    SIGNAL_CYAN = "#00FFD4"   # Positive indicators
    SIGNAL_CORAL = "#FF4757"  # Negative indicators
    SIGNAL_AMBER = "#FFAA00"  # Attention/Filter chips (nova-amber)
    SIGNAL_BLUE = "#4A9EFF"   # Reference/info

    # Backgrounds
    BG_BASE = "#0C0C12"
    BG_SURFACE = "#141420"
    BG_ELEVATED = "#1E1E2C"
    BG_BORDER = "#2A2A3A"

    # Text
    TEXT_PRIMARY = "#F4F4F8"
    TEXT_SECONDARY = "#9898A8"
    TEXT_DISABLED = "#5C5C6C"

class Spacing:
    XS = 4
    SM = 8
    MD = 12
    LG = 16
    XL = 24
    XXL = 32

class Limits:
    """Application limits."""
    MAX_FILTERS = 10
    MIN_WINDOW_WIDTH = 1280
    MIN_WINDOW_HEIGHT = 720
    MAX_RECENT_FILES = 10
    CACHE_MAX_AGE_DAYS = 30
```

### AppState Integration Pattern
[Source: architecture/2-high-level-architecture.md#Signal Flow]

```python
# In FeatureExplorerTab._on_filters_applied
def _on_filters_applied(self, filters: list[FilterCriteria]) -> None:
    """Handle filter application."""
    self._app_state.filters = filters
    
    # Apply filters to baseline data
    engine = FilterEngine()
    filtered_df = engine.apply_filters(self._app_state.baseline_df, filters)
    
    self._app_state.filtered_df = filtered_df
    self._app_state.filtered_data_updated.emit(filtered_df)

def _on_filters_cleared(self) -> None:
    """Handle filter clear."""
    self._app_state.filters = []
    self._app_state.filtered_df = self._app_state.baseline_df
    self._app_state.filtered_data_updated.emit(self._app_state.baseline_df)
```

### Coding Standards
[Source: architecture/9-coding-standards.md]

- **Line length**: 100 characters
- **Type hints**: Required for all public APIs
- **Naming**:
  - Modules: snake_case (`filter_engine.py`)
  - Classes: PascalCase (`FilterEngine`, `FilterChip`)
  - Private methods: Leading underscore (`_apply_style()`)
  - Qt Signals: snake_case (`filters_applied`)
  - Qt Slots: on_noun_verb (`on_filters_applied`)
- **Logging**: Use `logging.getLogger(__name__)` pattern
- **Pandas**: Use explicit `.copy()` when modifying filtered DataFrames

### Performance Requirements
[Source: PRD Story 2.2 AC 7]

| Operation | Target | Notes |
|-----------|--------|-------|
| Filter application | < 500ms for 100k rows | Vectorized pandas operations |

## Testing

### Test File Locations
[Source: architecture/8-testing-strategy.md]

- Unit tests: `tests/unit/test_filter_criteria.py`, `tests/unit/test_filter_engine.py`
- Widget tests: `tests/widget/test_filter_chip.py`, `tests/widget/test_filter_panel.py`
- Integration tests: `tests/integration/test_filter_workflow.py`
- Performance tests: `tests/integration/test_performance.py`

### Testing Standards
[Source: architecture/8-testing-strategy.md]

- Use pytest as test framework
- Use pytest-qt for widget testing (qtbot fixture)
- Mark slow tests with `@pytest.mark.slow`
- Use `tmp_path` fixture for temporary directories
- Use `sample_trades` and `sample_filters` fixtures from conftest.py

### Key Test Cases

**Unit Tests** (`tests/unit/test_filter_criteria.py`):

```python
def test_between_filter_includes_boundaries():
    """BETWEEN filter includes min and max values."""
    df = pd.DataFrame({"gain_pct": [0, 5, 10]})
    criteria = FilterCriteria(column="gain_pct", operator="between", min_val=0, max_val=10)
    mask = criteria.apply(df)
    assert mask.all()  # All values should match

def test_not_between_filter_excludes_range():
    """NOT BETWEEN filter excludes values in range."""
    df = pd.DataFrame({"gain_pct": [-5, 5, 15]})
    criteria = FilterCriteria(column="gain_pct", operator="not_between", min_val=0, max_val=10)
    mask = criteria.apply(df)
    assert mask.tolist() == [True, False, True]

def test_validate_returns_error_when_min_greater_than_max():
    """validate() returns error when min > max."""
    criteria = FilterCriteria(column="gain_pct", operator="between", min_val=10, max_val=5)
    error = criteria.validate()
    assert error is not None
    assert "Min" in error
```

**Unit Tests** (`tests/unit/test_filter_engine.py`):

```python
def test_apply_filters_and_logic(sample_trades):
    """Multiple filters combine with AND logic."""
    engine = FilterEngine()
    filters = [
        FilterCriteria(column="gain_pct", operator="between", min_val=0, max_val=10),
        FilterCriteria(column="gain_pct", operator="between", min_val=5, max_val=15),
    ]
    result = engine.apply_filters(sample_trades, filters)
    # Only values between 5 and 10 should match (intersection)
    assert (result["gain_pct"] >= 5).all()
    assert (result["gain_pct"] <= 10).all()

def test_apply_filters_returns_copy(sample_trades):
    """Filtered DataFrame is a copy, not a view."""
    engine = FilterEngine()
    filters = [FilterCriteria(column="gain_pct", operator="between", min_val=0, max_val=5)]
    result = engine.apply_filters(sample_trades, filters)
    # Modifying result should not affect original
    result["gain_pct"] = 999
    assert (sample_trades["gain_pct"] != 999).any()
```

**Widget Tests** (`tests/widget/test_filter_chip.py`):

```python
def test_filter_chip_displays_summary(qtbot):
    """FilterChip shows filter criteria summary."""
    criteria = FilterCriteria(column="gain_pct", operator="between", min_val=0, max_val=10)
    chip = FilterChip(criteria)
    qtbot.addWidget(chip)
    
    assert "gain_pct" in chip._label.text()
    assert "between" in chip._label.text()
    assert "0" in chip._label.text()
    assert "10" in chip._label.text()

def test_filter_chip_remove_emits_signal(qtbot):
    """Remove button emits signal with criteria."""
    criteria = FilterCriteria(column="gain_pct", operator="between", min_val=0, max_val=10)
    chip = FilterChip(criteria)
    qtbot.addWidget(chip)
    
    with qtbot.waitSignal(chip.removed) as blocker:
        chip._remove_btn.click()
    
    assert blocker.args[0] == criteria
```

**Performance Test** (`tests/integration/test_performance.py`):

```python
@pytest.mark.slow
def test_filter_response_under_500ms(large_dataset_path):
    """NFR2: Filter application < 500ms for 100k rows."""
    from time import perf_counter
    from src.core.file_loader import FileLoader
    from src.core.filter_engine import FilterEngine
    from src.core.models import FilterCriteria
    
    loader = FileLoader()
    df = loader.load(large_dataset_path)
    
    engine = FilterEngine()
    criteria = FilterCriteria(column="gain_pct", operator="between", min_val=0, max_val=10)
    
    start = perf_counter()
    result = engine.apply_filters(df, [criteria])
    elapsed = perf_counter() - start
    
    assert elapsed < 0.5, f"Filter took {elapsed:.3f}s, exceeds 500ms limit"
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-10 | 0.1 | Initial draft | SM Agent (Bob) |
| 2026-01-10 | 0.2 | Added Task 0 for Limits class (validation fix) | PO Agent (Sarah) |

---

## Dev Agent Record

### Agent Model Used

Claude Opus 4.5 (claude-opus-4-5-20251101)

### Debug Log References

None - No blocking issues encountered during implementation.

### Completion Notes List

- All 16 tasks (Task 0-15) completed successfully
- All 262 tests passing (including 44 new tests for filter functionality)
- Lint clean (0 errors)
- Type check clean (0 errors)
- Performance test confirms filter application < 500ms for 100k rows
- AppState.filters type annotation updated from `list[object]` to `list[FilterCriteria]`
- FilterEngine returns explicit copy using `.copy()` per specification

### File List

**New Files:**
- `src/core/filter_engine.py` - FilterEngine class
- `src/ui/components/filter_chip.py` - FilterChip component
- `src/ui/components/filter_row.py` - FilterRow component
- `src/ui/components/filter_panel.py` - FilterPanel container
- `tests/unit/test_filter_criteria.py` - FilterCriteria unit tests (12 tests)
- `tests/unit/test_filter_engine.py` - FilterEngine unit tests (10 tests)
- `tests/widget/test_filter_chip.py` - FilterChip widget tests (6 tests)
- `tests/widget/test_filter_panel.py` - FilterPanel widget tests (12 tests)
- `tests/integration/test_filter_workflow.py` - Filter workflow integration tests (6 tests)

**Modified Files:**
- `src/core/models.py` - Added FilterCriteria dataclass
- `src/core/__init__.py` - Export FilterEngine and FilterCriteria
- `src/core/app_state.py` - Updated filters type annotation
- `src/ui/constants.py` - Added Limits class
- `src/ui/components/__init__.py` - Export FilterChip, FilterRow, FilterPanel
- `src/tabs/feature_explorer.py` - Integrated FilterPanel, added filter handlers
- `tests/conftest.py` - Added sample_trades and sample_filters fixtures
- `tests/integration/test_performance.py` - Added filter performance tests (2 tests)

---

## QA Results

### Pre-Implementation Assessment: 2026-01-10

### Reviewed By: Quinn (Test Architect)

### Assessment Type

**Pre-Implementation Review** - Story is in Draft status with no implementation yet. This assessment covers risk profiling and design review.

### Risk Profile Summary

| Category | Critical | High | Medium | Low | Total |
|----------|----------|------|--------|-----|-------|
| Risks    | 0        | 2    | 4      | 3   | 9     |

**Risk Score: 70/100**

### High Priority Risks Identified

1. **TECH-001: Complex Signal Chain Management** (Score: 6)
   - FilterPanel → FeatureExplorerTab → AppState → Chart signal chain
   - Mitigation: Add logging at each signal point, integration test for full chain

2. **DATA-001: DataFrame View vs Copy** (Score: 6)
   - Risk of modifying views instead of copies when filtering
   - Mitigation: Explicit `.copy()` in FilterEngine (spec already requires this), add verification test

### Design Review Notes

**Strengths:**
- Well-structured component hierarchy (FilterCriteria → FilterEngine → FilterChip/Row/Panel)
- Clear separation of concerns between model, engine, and UI
- Explicit performance target (AC7: <500ms for 100k rows)
- Comprehensive task breakdown with clear acceptance criteria mapping
- Type hints and docstrings specified per coding standards

**Areas Requiring Attention:**
- Signal chain complexity across 4+ components
- Widget lifecycle management (dynamic create/destroy of FilterRow/FilterChip)
- AppState.filters type annotation currently `list[object]`, needs update to `list[FilterCriteria]`

### Compliance Check (Pre-Implementation)

- Coding Standards: ✓ Spec follows naming conventions, logging patterns
- Project Structure: ✓ File locations align with architecture
- Testing Strategy: ✓ Unit/widget/integration/performance tests planned
- All ACs Met: ⏳ Pending implementation

### Pre-Implementation Checklist

- [ ] FilterEngine.apply_filters() must return explicit `.copy()`
- [ ] Add logging at each signal emission point
- [ ] Integration test: button click → filter applied → chart updated
- [ ] Performance test: verify <500ms for 100k rows
- [ ] Update AppState.filters type annotation after FilterCriteria exists
- [ ] Widget cleanup: use deleteLater() for removed FilterRow/FilterChip

### Gate Status

Gate: CONCERNS → docs/qa/gates/2.2-bounds-filtering.yml
Risk profile: docs/qa/assessments/2.2-risk-20260110.md

### Recommended Next Steps

1. **Proceed with implementation** - No critical risks identified
2. **Request full QA review** when story moves to Review status
3. **Address pre-implementation checklist** during development

### Notes

This is a pre-implementation assessment. A full code review will be conducted when:
- Story status changes to "Review"
- All tasks are completed
- All tests are passing

---

### Review Date: 2026-01-10

### Reviewed By: Quinn (Test Architect)

### Review Type

**Full Implementation Review** - Deep review triggered by: previous gate CONCERNS, 7 ACs (>5 threshold).

### Code Quality Assessment

**Overall: Excellent** - Implementation is clean, well-structured, and follows all specified patterns.

**FilterCriteria Model** (`src/core/models.py:118-147`)
- Properly implements `validate()` returning error message or None
- `apply()` method returns correct boolean mask for both operators
- Type hints and docstrings complete

**FilterEngine** (`src/core/filter_engine.py`)
- AND logic correctly implemented with boolean mask chaining
- Explicit `.copy()` call ensures no view/copy issues ✓
- Logging at DEBUG level for filter operations ✓

**UI Components** (`src/ui/components/filter_*.py`)
- FilterChip: Proper signal emission, nova-amber styling
- FilterRow: Input validation via QDoubleValidator, proper operator mapping
- FilterPanel: Correct widget lifecycle with `deleteLater()`, max filter limit enforced

**Integration** (`src/tabs/feature_explorer.py:246-280`)
- Signal chain correctly wired: FilterPanel → FeatureExplorerTab → AppState → Chart
- AppState.filters type annotation correctly uses TYPE_CHECKING import pattern
- filtered_data_updated signal properly emits DataFrame

### Refactoring Performed

None required - implementation is clean and follows specifications.

### Compliance Check

- Coding Standards: ✓ All naming conventions followed, type hints present, logging used
- Project Structure: ✓ Files in correct locations per architecture spec
- Testing Strategy: ✓ Unit/widget/integration/performance tests all present
- All ACs Met: ✓ All 7 acceptance criteria implemented and tested

### Requirements Traceability

| AC | Description | Implementation | Tests |
|----|-------------|----------------|-------|
| 1 | Add Filter button with row | FilterPanel, FilterRow | test_filter_panel.py:12-25 |
| 2 | Operators between/not between | FilterCriteria.operator | test_filter_criteria.py:1-58 |
| 3 | Filter validation | FilterCriteria.validate(), FilterRow.get_criteria() | test_filter_criteria.py:61-86 |
| 4 | Apply updates chart | FeatureExplorerTab._on_filters_applied | test_filter_workflow.py |
| 5 | Chips shown | FilterChip component | test_filter_chip.py |
| 6 | Clear All resets | FilterPanel._on_clear_filters | test_filter_panel.py:58-85 |
| 7 | <500ms for 100k | FilterEngine vectorized ops | test_performance.py:72-95 |

### Test Coverage Summary

| Test Type | File | Tests | Status |
|-----------|------|-------|--------|
| Unit | test_filter_criteria.py | 12 | ✓ Pass |
| Unit | test_filter_engine.py | 10 | ✓ Pass |
| Widget | test_filter_chip.py | 6 | ✓ Pass |
| Widget | test_filter_panel.py | 12 | ✓ Pass |
| Integration | test_filter_workflow.py | 6 | ✓ Pass |
| Performance | test_performance.py | 2 (filter) | ✓ Pass |
| **Total** | | **48** | **All Pass** |

### Security Review

✓ **PASS** - No security concerns.
- Input validation via QDoubleValidator prevents injection
- No external attack surface (local desktop application)
- Filter values bounded to numeric types only

### Performance Considerations

✓ **PASS** - AC7 performance requirement met.
- Filter application verified <500ms for 100k rows
- Vectorized pandas operations used (boolean mask chaining)
- Test confirms multiple filters also complete <500ms

### Files Modified During Review

None - no refactoring required.

### Gate Status

Gate: **PASS** → docs/qa/gates/2.2-bounds-filtering.yml

### Recommended Status

✓ **Ready for Done** - All acceptance criteria implemented, all tests passing, no blocking issues.
