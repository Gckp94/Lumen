# Story 6.3: Bin Configuration Persistence

## Status
Done

## Story
**As a** trader analyzing my trade data,
**I want** to save and load my bin configurations,
**so that** I can reuse complex bin setups across sessions without reconfiguring them each time.

## Acceptance Criteria

1. Save button opens file dialog to save current bin configuration as JSON
2. Load button opens file dialog to load a previously saved bin configuration
3. Configuration file includes: column name, all bin definitions, and metric selection (gain_pct/adjusted_gain_pct)
4. Loading a configuration populates the column dropdown, bin rows, and metric toggle
5. Invalid configuration files show an error toast without crashing
6. Save/Load operations show success/error toast feedback after file I/O completes
7. File dialog remembers last used directory within the session

## Tasks / Subtasks

- [x] Task 1: Create BinConfig dataclass for serialization (AC: 3)
  - [x] Create `BinConfig` dataclass in `src/core/models.py` after `BinMetrics`
  - [x] Include fields: `column: str`, `bins: list[BinDefinition]`, `metric_column: str`
  - [x] Add `to_dict() -> dict` method for JSON serialization
  - [x] Add `from_dict(data: dict) -> BinConfig` class method for deserialization
  - [x] Add `validate() -> list[str]` method returning list of validation errors

- [x] Task 2: Add Save/Load buttons to DataBinningTab sidebar (AC: 1, 2)
  - [x] Add "Save Config" button below the Add Bin button
  - [x] Add "Load Config" button below Save Config button
  - [x] Set object names for test discovery: `setObjectName("save_config_btn")`, `setObjectName("load_config_btn")`
  - [x] Style buttons using existing UI constants (Spacing, Colors)
  - [x] Add horizontal separator between bin configuration and save/load buttons

- [x] Task 3: Implement save configuration functionality (AC: 1, 3, 6, 7)
  - [x] Add `_on_save_config_clicked()` slot method
  - [x] Use `QFileDialog.getSaveFileName()` with filter "JSON Files (*.json)"
  - [x] Collect current column, bin definitions, and metric selection into BinConfig
  - [x] Serialize to JSON using `json.dump()` with `indent=2`
  - [x] Store last used directory in instance variable `_last_save_dir: Path | None`
  - [x] Initialize `_last_save_dir` to `None`; use `str(self._last_save_dir or Path.home())` as dialog starting directory
  - [x] Update `_last_save_dir` to parent directory of saved file after successful save
  - [x] Show success toast after save; show error toast if no bins configured or save fails

- [x] Task 4: Implement load configuration functionality (AC: 2, 4, 5, 6, 7)
  - [x] Add `_on_load_config_clicked()` slot method
  - [x] Use `QFileDialog.getOpenFileName()` with filter "JSON Files (*.json)"
  - [x] Use `str(self._last_save_dir or Path.home())` as dialog starting directory
  - [x] Update `_last_save_dir` to parent directory of loaded file after successful load
  - [x] Parse JSON and validate using `BinConfig.from_dict()` and `validate()`
  - [x] On validation errors, show error toast with specific message
  - [x] Set column dropdown to loaded column if column exists in current data
  - [x] If loaded column not in current data: show warning toast "Column '{name}' not found in data. Please select a column manually.", still populate bin rows
  - [x] Clear existing bin rows and populate with loaded bin definitions
  - [x] Set metric toggle to loaded metric selection
  - [x] Show success toast after successful load
  - [x] Emit `bin_config_changed` signal after loading

- [x] Task 5: Unit tests for BinConfig (`tests/unit/test_binning_engine.py`) (AC: 3, 5)
  - [x] Test `to_dict()` produces correct JSON-serializable dict
  - [x] Test `from_dict()` correctly reconstructs BinConfig
  - [x] Test `validate()` catches missing column
  - [x] Test `validate()` catches empty bins list
  - [x] Test `validate()` catches invalid metric_column values
  - [x] Test round-trip serialization (to_dict -> from_dict -> to_dict)

- [x] Task 6: Widget tests for save/load functionality (`tests/widget/test_data_binning.py`) (AC: 1, 2, 4)
  - [x] Test save button exists and is clickable
  - [x] Test load button exists and is clickable
  - [x] Test `_get_current_config()` returns correct BinConfig
  - [x] Test `_apply_config()` correctly populates UI from BinConfig
  - [x] Test bin_config_changed signal emits after load

## Dev Notes

### Previous Story (6.2) Key Insights
[Source: docs/stories/6.2.story.md#dev-agent-record]

Story 6.2 completed:
- `BinningEngine` class in `src/core/binning_engine.py`
- `BinMetrics` dataclass in `src/core/models.py`
- `HorizontalBarChart` and `BinChartPanel` classes in `src/tabs/data_binning.py`
- Signals: `column_selected`, `bin_config_changed` already connected
- Metric toggle uses two `QPushButton` styled buttons (not ToggleSwitch)
- 69 tests passing (25 unit + 44 widget)

### BinDefinition Dataclass
[Source: src/core/models.py:383-397]

```python
@dataclass
class BinDefinition:
    """Single bin definition for data binning."""
    operator: Literal["<", ">", "range", "nulls"]
    value1: float | None = None  # For <, >, or range start
    value2: float | None = None  # For range end only
    label: str = ""  # User-friendly label (auto-generated if empty)
```

### BinConfig Dataclass (New)

Add to `src/core/models.py` after `BinMetrics` (insert at approximately line 418, after BinMetrics ends at line 416):

```python
@dataclass
class BinConfig:
    """Complete bin configuration for save/load persistence."""
    column: str
    bins: list[BinDefinition]
    metric_column: str = "adjusted_gain_pct"  # or "gain_pct"

    def to_dict(self) -> dict:
        """Convert to JSON-serializable dictionary."""
        return {
            "column": self.column,
            "bins": [
                {
                    "operator": b.operator,
                    "value1": b.value1,
                    "value2": b.value2,
                    "label": b.label,
                }
                for b in self.bins
            ],
            "metric_column": self.metric_column,
        }

    @classmethod
    def from_dict(cls, data: dict) -> "BinConfig":
        """Create BinConfig from dictionary.

        Raises:
            KeyError: If required fields are missing.
            TypeError: If field types are invalid.
        """
        bins = [
            BinDefinition(
                operator=b["operator"],
                value1=b.get("value1"),
                value2=b.get("value2"),
                label=b.get("label", ""),
            )
            for b in data["bins"]
        ]
        return cls(
            column=data["column"],
            bins=bins,
            metric_column=data.get("metric_column", "adjusted_gain_pct"),
        )

    def validate(self) -> list[str]:
        """Validate configuration. Returns list of error messages."""
        errors = []
        if not self.column:
            errors.append("Column name is required")
        if not self.bins:
            errors.append("At least one bin definition is required")
        if self.metric_column not in ("gain_pct", "adjusted_gain_pct"):
            errors.append(f"Invalid metric column: {self.metric_column}")
        return errors
```

### Existing Persistence Pattern
[Source: src/core/column_mapper.py:151-193]

The ColumnMapper uses JSON for persistence with `json.dump()` and `json.load()`:

```python
# Save pattern
with open(cache_path, "w", encoding="utf-8") as f:
    json.dump(asdict(mapping), f, indent=2)

# Load pattern
with open(cache_path, encoding="utf-8") as f:
    data = json.load(f)
return ColumnMapping(**data)
```

### QFileDialog Pattern
[Source: src/tabs/pnl_stats.py:303-310, src/tabs/data_input.py:1285-1290]

```python
from PyQt6.QtWidgets import QFileDialog

# Save dialog
path, _ = QFileDialog.getSaveFileName(
    self,
    "Save Bin Configuration",
    default_name,  # e.g., "bin_config.json"
    "JSON Files (*.json)",
)
if not path:
    return  # User cancelled

# Load dialog
path, _ = QFileDialog.getOpenFileName(
    self,
    "Load Bin Configuration",
    "",
    "JSON Files (*.json)",
)
if not path:
    return  # User cancelled
```

### DataBinningTab Current Structure
[Source: src/tabs/data_binning.py]

Key methods to use/extend:
- `get_bin_definitions() -> list[BinDefinition]` - already exists, returns current bins
- `_add_bin_row(bin_def: BinDefinition | None)` - creates BinConfigRow widget
- `_clear_bin_rows()` - removes all bin configuration rows
- `_on_column_selected(index: int)` - handles column dropdown change

Add new methods:
- `_get_current_config() -> BinConfig | None` - collect current state into BinConfig
- `_apply_config(config: BinConfig) -> None` - populate UI from BinConfig
- `_on_save_config_clicked() -> None` - handle save button
- `_on_load_config_clicked() -> None` - handle load button

### UI Button Styling
[Source: docs/architecture/9-coding-standards.md#theme-constants]

```python
from src.ui.constants import Colors, Spacing

save_btn = QPushButton("Save Config")
save_btn.setStyleSheet(f"""
    QPushButton {{
        background-color: {Colors.BG_ELEVATED};
        color: {Colors.TEXT_PRIMARY};
        border: 1px solid {Colors.BG_BORDER};
        border-radius: 4px;
        padding: {Spacing.SM}px {Spacing.MD}px;
    }}
    QPushButton:hover {{
        background-color: {Colors.BG_BORDER};
    }}
""")
```

### Toast Notification Pattern
[Source: src/tabs/pnl_stats.py:333-339, src/tabs/feature_explorer.py:798-805]

```python
from src.ui.components.toast import Toast

# Show error toast
Toast.display(self, "Invalid configuration file", "error", duration=5000)

# Show success toast
Toast.display(self, "Configuration saved", "success")

# Variants: "success", "error", "info"
# Default duration: 3000ms
```

### File Locations
[Source: docs/architecture/2-high-level-architecture.md#repository-structure]

- Modify: `src/core/models.py` (add BinConfig dataclass)
- Modify: `src/tabs/data_binning.py` (add save/load buttons and handlers)
- Extend tests: `tests/unit/test_binning_engine.py` (BinConfig unit tests)
- Extend tests: `tests/widget/test_data_binning.py` (save/load widget tests)

### JSON File Format Example

```json
{
  "column": "volume",
  "bins": [
    {"operator": "<", "value1": 1000000, "value2": null, "label": "< 1M"},
    {"operator": "range", "value1": 1000000, "value2": 10000000, "label": "1M-10M"},
    {"operator": ">", "value1": 10000000, "value2": null, "label": "> 10M"},
    {"operator": "nulls", "value1": null, "value2": null, "label": "Nulls"}
  ],
  "metric_column": "adjusted_gain_pct"
}
```

## Testing

### Test File Locations
- Unit tests: `tests/unit/test_binning_engine.py` (extend existing)
- Widget tests: `tests/widget/test_data_binning.py` (extend existing)

### Test Standards
[Source: docs/architecture/8-testing-strategy.md]

- Use pytest + pytest-qt for widget tests
- Use `qtbot.addWidget(widget)` for proper cleanup
- Use `tmp_path` fixture for file I/O tests
- Test signal emissions with `qtbot.waitSignal()`

### Required Fixtures
- `tmp_path` - pytest built-in for temporary directories
- `sample_dataframe` - from conftest.py

### Example Unit Tests

```python
def test_bin_config_to_dict():
    """to_dict produces JSON-serializable output."""
    bins = [BinDefinition(operator="<", value1=100, label="Low")]
    config = BinConfig(column="volume", bins=bins, metric_column="gain_pct")

    result = config.to_dict()

    assert result["column"] == "volume"
    assert len(result["bins"]) == 1
    assert result["bins"][0]["operator"] == "<"
    # Verify JSON-serializable
    import json
    json.dumps(result)  # Should not raise

def test_bin_config_from_dict():
    """from_dict correctly reconstructs BinConfig."""
    data = {
        "column": "volume",
        "bins": [{"operator": "<", "value1": 100, "label": "Low"}],
        "metric_column": "gain_pct",
    }

    config = BinConfig.from_dict(data)

    assert config.column == "volume"
    assert len(config.bins) == 1
    assert config.bins[0].operator == "<"

def test_bin_config_validate_empty_bins():
    """validate catches empty bins list."""
    config = BinConfig(column="volume", bins=[], metric_column="gain_pct")

    errors = config.validate()

    assert any("bin" in e.lower() for e in errors)

def test_bin_config_roundtrip():
    """Round-trip serialization preserves data."""
    bins = [
        BinDefinition(operator="<", value1=100, label="Low"),
        BinDefinition(operator="range", value1=100, value2=1000, label="Mid"),
    ]
    original = BinConfig(column="volume", bins=bins, metric_column="adjusted_gain_pct")

    restored = BinConfig.from_dict(original.to_dict())

    assert restored.column == original.column
    assert len(restored.bins) == len(original.bins)
    assert restored.metric_column == original.metric_column
```

### Example Widget Tests

```python
def test_save_button_exists(qtbot, sample_dataframe, mock_app_state):
    """Save Config button exists in sidebar."""
    tab = DataBinningTab(mock_app_state)
    qtbot.addWidget(tab)

    save_btn = tab.findChild(QPushButton, "save_config_btn")
    assert save_btn is not None
    assert save_btn.text() == "Save Config"

def test_load_button_exists(qtbot, sample_dataframe, mock_app_state):
    """Load Config button exists in sidebar."""
    tab = DataBinningTab(mock_app_state)
    qtbot.addWidget(tab)

    load_btn = tab.findChild(QPushButton, "load_config_btn")
    assert load_btn is not None
    assert load_btn.text() == "Load Config"

def test_apply_config_populates_ui(qtbot, sample_dataframe, mock_app_state):
    """_apply_config correctly sets UI state."""
    tab = DataBinningTab(mock_app_state)
    qtbot.addWidget(tab)

    bins = [BinDefinition(operator="<", value1=100, label="Low")]
    config = BinConfig(column="volume", bins=bins, metric_column="gain_pct")

    tab._apply_config(config)

    # Verify column dropdown
    assert tab._column_dropdown.currentText() == "volume"
    # Verify bin rows created
    assert len(tab._bin_rows) == 1
```

### Coding Standards
[Source: docs/architecture/9-coding-standards.md]

- Line length: 100 characters (Black formatter)
- Naming: snake_case for methods, PascalCase for classes
- Qt signals: snake_case (e.g., `config_loaded`)
- Qt slots: on_noun_verb (e.g., `_on_save_config_clicked`)
- Type hints required for all public APIs
- Use `Path` from pathlib for file paths

## Dev Agent Record

### Agent Model Used
Claude Opus 4.5

### File List
| File | Action | Description |
|------|--------|-------------|
| src/core/models.py | Modified | Added BinConfig dataclass with to_dict, from_dict, validate methods |
| src/tabs/data_binning.py | Modified | Added Save/Load buttons, _get_current_config, _apply_config, _on_save_config_clicked, _on_load_config_clicked methods |
| tests/unit/test_binning_engine.py | Modified | Added TestBinConfigDataclass with 8 test cases |
| tests/widget/test_data_binning.py | Modified | Added TestSaveLoadConfig with 7 test cases |

### Debug Log References
None required.

### Completion Notes
- All 6 tasks completed with all subtasks
- 8 new unit tests for BinConfig (33 total in test_binning_engine.py)
- 7 new widget tests for save/load (51 total in test_data_binning.py)
- Full regression: 1172 passed, 2 failed (pre-existing flaky performance tests unrelated to this story)
- BinConfig dataclass at src/core/models.py:419-475
- Save/Load buttons with separator at src/tabs/data_binning.py in _create_sidebar method
- Configuration methods at src/tabs/data_binning.py:565-680

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-13 | 1.0 | Initial story creation | Bob (SM Agent) |
| 2026-01-13 | 1.1 | PO validation: Fixed Toast API pattern, added button object names for tests, clarified AC6 feedback, specified BinConfig line location, added directory initialization default, added column-not-found handling on load | Sarah (PO Agent) |
| 2026-01-13 | 1.2 | Implementation complete: All tasks and tests passing | James (Dev Agent) |

## QA Results

### Review Date: 2026-01-13

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall: Excellent** - Implementation is clean, well-structured, and follows established patterns. The BinConfig dataclass at `src/core/models.py:419-475` follows the exact spec from Dev Notes with proper serialization methods. The save/load UI implementation at `src/tabs/data_binning.py:565-707` demonstrates proper error handling, consistent Toast notification patterns, and appropriate signal emissions.

**Strengths:**
- Clean dataclass design with proper separation of concerns (to_dict, from_dict, validate)
- Comprehensive exception handling: JSONDecodeError, KeyError, TypeError, OSError all caught with user-friendly toasts
- Good graceful degradation: column-not-found case shows info toast but still loads bin definitions
- Follows established project patterns (QFileDialog usage, Toast API, button styling)

### Refactoring Performed

None required - implementation is well-structured.

### Compliance Check

- Coding Standards: ✓ snake_case methods, PascalCase class, proper type hints, 100-char line limit
- Project Structure: ✓ Models in models.py, UI in tabs/data_binning.py, tests in proper locations
- Testing Strategy: ✓ Unit tests for dataclass, widget tests for UI, proper pytest-qt patterns
- All ACs Met: ✓ All 7 acceptance criteria verified (see Requirements Traceability below)

### Requirements Traceability

| AC | Requirement | Test Coverage | Status |
|----|-------------|---------------|--------|
| 1 | Save button opens file dialog to save JSON | `test_save_button_exists`, `_on_save_config_clicked` uses `QFileDialog.getSaveFileName` | ✓ |
| 2 | Load button opens file dialog to load JSON | `test_load_button_exists`, `_on_load_config_clicked` uses `QFileDialog.getOpenFileName` | ✓ |
| 3 | Config includes column, bins, metric | `test_bin_config_to_dict`, `test_get_current_config_returns_binconfig` | ✓ |
| 4 | Loading populates dropdown, bins, metric | `test_apply_config_populates_ui`, verifies column/bins/metric restoration | ✓ |
| 5 | Invalid files show error toast, no crash | `test_bin_config_validate_*` + exception handlers in `_on_load_config_clicked` | ✓ |
| 6 | Success/error toast feedback | Implementation shows Toast for save/load success/errors | ✓ |
| 7 | File dialog remembers directory | `test_last_save_dir_initialized_to_none`, `_last_save_dir` updates on save/load | ✓ |

### Improvements Checklist

- [x] All acceptance criteria implemented
- [x] Unit tests for BinConfig serialization (8 tests)
- [x] Widget tests for save/load buttons and behavior (7 tests)
- [x] Error handling covers JSON, schema, and file system errors
- [x] Graceful handling of missing columns during load
- [ ] Consider: Add integration test for actual file save/load roundtrip (would require tmp_path + monkeypatching QFileDialog)

### Security Review

**Status: PASS** - No security concerns. File I/O uses standard Qt dialog (sandboxed), JSON parsing is read-only without code execution, and all user paths are validated through Qt's native dialogs.

### Performance Considerations

**Status: PASS** - Save/load operations are O(n) where n = number of bins (typically < 20). No performance concerns for expected use cases.

### Files Modified During Review

None - no refactoring required.

### Gate Status

Gate: **PASS** → docs/qa/gates/6.3-bin-configuration-persistence.yml

### Recommended Status

✓ **Ready for Done** - All acceptance criteria met, comprehensive test coverage, clean implementation following project patterns.
