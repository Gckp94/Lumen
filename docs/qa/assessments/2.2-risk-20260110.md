# Risk Profile: Story 2.2 - Bounds Filtering

Date: 2026-01-10
Reviewer: Quinn (Test Architect)

## Executive Summary

- Total Risks Identified: 9
- Critical Risks: 0
- High Risks: 2
- Medium Risks: 4
- Low Risks: 3
- Risk Score: 70/100

Story 2.2 introduces bounds-based filtering to the Feature Explorer. The implementation involves new UI components (FilterChip, FilterRow, FilterPanel), core filtering logic (FilterEngine, FilterCriteria), and integration with existing AppState. Primary risks center around PyQt6 signal management, DataFrame mutation safety, and performance with large datasets.

## Risk Matrix

| Risk ID   | Description                              | Probability | Impact     | Score | Priority |
|-----------|------------------------------------------|-------------|------------|-------|----------|
| TECH-001  | Complex signal chain management          | Medium (2)  | High (3)   | 6     | High     |
| TECH-002  | Widget lifecycle management              | Medium (2)  | Medium (2) | 4     | Medium   |
| DATA-001  | DataFrame view vs copy confusion         | Medium (2)  | High (3)   | 6     | High     |
| DATA-002  | Filter state inconsistency               | Low (1)     | Medium (2) | 2     | Low      |
| PERF-001  | 100k row filter performance              | Low (1)     | Medium (2) | 2     | Low      |
| SEC-001   | Input validation bypass                  | Low (1)     | Low (1)    | 1     | Minimal  |
| BUS-001   | UI responsiveness during filter          | Medium (2)  | Medium (2) | 4     | Medium   |
| OPS-001   | Error message clarity                    | Medium (2)  | Low (1)    | 2     | Low      |
| TECH-003  | Type annotation gaps                     | Medium (2)  | Medium (2) | 4     | Medium   |

## Critical Risks Requiring Immediate Attention

*No critical risks (score 9) identified.*

## High Risks (Score 6)

### 1. TECH-001: Complex Signal Chain Management

**Score: 6 (High)**

**Probability**: Medium - Multiple components emit and receive signals in sequence
**Impact**: High - Broken signal chains cause UI to desync from data state

**Description**:
The filter workflow requires a complex signal chain:
- FilterPanel.filters_applied → FeatureExplorerTab._on_filters_applied
- FilterEngine processes → AppState.filtered_df updated
- AppState.filtered_data_updated → Chart refresh

If any link breaks, users see stale data or no update at all.

**Affected Components**:
- `FilterPanel.filters_applied` signal
- `FeatureExplorerTab._on_filters_applied` slot
- `AppState.filtered_data_updated` signal

**Mitigation**:
- Strategy: Preventive
- Actions:
  - Add logging at each signal emission and reception point
  - Implement signal connection validation in tests
  - Use `QObject.blockSignals()` carefully during batch updates
  - Add integration test verifying full signal chain
- Testing Requirements:
  - Widget test: FilterPanel emits correct signal with criteria list
  - Integration test: Full chain from button click to chart update
- Residual Risk: Low - With logging and tests, broken chains will be caught early
- Owner: dev
- Timeline: During implementation

### 2. DATA-001: DataFrame View vs Copy Confusion

**Score: 6 (High)**

**Probability**: Medium - Common pandas pitfall, especially with filtering
**Impact**: High - Modifying views corrupts baseline data

**Description**:
When filtering DataFrames with boolean masks, pandas may return views instead of copies. If filtered_df is a view of baseline_df and gets modified (e.g., in chart updates or downstream processing), baseline data gets corrupted silently.

The story spec correctly specifies `df[mask].copy()` but implementation must be verified.

**Affected Components**:
- `FilterEngine.apply_filters()` return value
- `AppState.filtered_df` assignment

**Mitigation**:
- Strategy: Preventive + Detective
- Actions:
  - Explicitly call `.copy()` in FilterEngine (spec already requires this)
  - Add unit test verifying returned DataFrame is independent copy
  - Use `pd.options.mode.copy_on_write = True` if pandas 2.0+ (optional)
- Testing Requirements:
  - Unit test: Modify filtered result, verify baseline unchanged
  - Code review: Verify `.copy()` call exists
- Residual Risk: Minimal - With explicit test, this is caught
- Owner: dev
- Timeline: During implementation

## Medium Risks (Score 4)

### 3. TECH-002: Widget Lifecycle Management

**Score: 4 (Medium)**

**Probability**: Medium - Dynamic widget creation/removal is error-prone
**Impact**: Medium - Memory leaks, dangling references

**Description**:
FilterRow and FilterChip widgets are dynamically created and destroyed. Improper cleanup can lead to:
- Memory leaks from orphaned widgets
- Dangling signal connections
- Qt object deletion issues

**Mitigation**:
- Strategy: Preventive
- Actions:
  - Use `deleteLater()` for removed widgets
  - Disconnect signals before widget removal
  - Set parent widgets correctly for automatic cleanup
  - Enforce MAX_FILTERS limit (10) to bound memory growth
- Testing Requirements:
  - Widget test: Add filters to max, remove all, verify no leaks
- Residual Risk: Low
- Owner: dev
- Timeline: During implementation

### 4. BUS-001: UI Responsiveness During Filter

**Score: 4 (Medium)**

**Probability**: Medium - 100k rows is substantial for UI thread
**Impact**: Medium - Perceived sluggishness, user frustration

**Description**:
AC7 requires <500ms filter time for 100k rows. While pandas vectorized operations are fast, running on UI thread could cause frame drops during the operation.

**Mitigation**:
- Strategy: Preventive
- Actions:
  - Verify 500ms target is achievable with vectorized pandas
  - Consider QApplication.processEvents() for very large datasets (optional)
  - Add performance test with 100k rows
- Testing Requirements:
  - Performance test: Filter 100k rows, measure wall time
- Residual Risk: Low - Vectorized pandas is typically <100ms for this
- Owner: dev
- Timeline: During implementation

### 5. TECH-003: Type Annotation Gaps

**Score: 4 (Medium)**

**Probability**: Medium - `AppState.filters: list[object]` is weakly typed
**Impact**: Medium - Runtime type errors, IDE support degraded

**Description**:
AppState currently has `filters: list[object]` placeholder. Story should update to `list[FilterCriteria]` but import cycles and TYPE_CHECKING blocks must be handled correctly.

**Mitigation**:
- Strategy: Preventive
- Actions:
  - Use `from __future__ import annotations` for forward references
  - Update AppState type annotation after FilterCriteria is defined
  - Run `make typecheck` to verify
- Testing Requirements:
  - mypy passes without errors
- Residual Risk: Minimal
- Owner: dev
- Timeline: During implementation

## Low Risks (Score 2-3)

### 6. DATA-002: Filter State Inconsistency

**Score: 2 (Low)**

**Probability**: Low - Clear state management pattern exists
**Impact**: Medium - Chips show different filters than applied

**Description**:
If filter state is stored in multiple places (FilterPanel internal state vs AppState.filters), they could desync.

**Mitigation**:
- Strategy: Preventive
- Actions:
  - Single source of truth: AppState.filters
  - FilterPanel only holds UI state, reads from AppState for display
- Residual Risk: Minimal
- Owner: dev

### 7. PERF-001: 100k Row Filter Performance

**Score: 2 (Low)**

**Probability**: Low - Vectorized pandas operations are highly optimized
**Impact**: Medium - Exceeds 500ms target

**Description**:
Story requires <500ms for 100k rows. Risk is low because:
- Boolean masking is O(n) with C-optimized numpy
- AND logic across filters is also vectorized
- No Python loops in hot path

**Mitigation**:
- Strategy: Detective
- Actions:
  - Add performance test marked `@pytest.mark.slow`
  - Measure actual performance during dev
- Residual Risk: Minimal
- Owner: dev

### 8. OPS-001: Error Message Clarity

**Score: 2 (Low)**

**Probability**: Medium - Validation errors need clear messaging
**Impact**: Low - User confusion, not data loss

**Description**:
When min > max validation fails, the error message should be clear and actionable.

**Mitigation**:
- Strategy: Preventive
- Actions:
  - Return specific error: "Min value must be less than or equal to max value"
  - Display error near the input field, not in a modal
- Residual Risk: Minimal
- Owner: dev

## Minimal Risks (Score 1)

### 9. SEC-001: Input Validation Bypass

**Score: 1 (Minimal)**

**Probability**: Low - UI enforces numeric input
**Impact**: Low - Internal app, no security boundary crossed

**Description**:
Users could theoretically paste non-numeric values into filter inputs.

**Mitigation**:
- Strategy: Preventive
- Actions:
  - QLineEdit with QDoubleValidator
  - FilterCriteria uses float type (parsing fails gracefully)
- Residual Risk: Minimal
- Owner: dev

## Risk Distribution

### By Category

| Category     | Count | High | Medium | Low |
|--------------|-------|------|--------|-----|
| Technical    | 3     | 1    | 2      | 0   |
| Data         | 2     | 1    | 0      | 1   |
| Performance  | 1     | 0    | 0      | 1   |
| Security     | 1     | 0    | 0      | 1   |
| Business     | 1     | 0    | 1      | 0   |
| Operational  | 1     | 0    | 0      | 1   |

### By Component

| Component          | Risks |
|--------------------|-------|
| FilterEngine       | 2     |
| FilterPanel        | 2     |
| AppState           | 2     |
| FilterCriteria     | 2     |
| FeatureExplorerTab | 1     |

## Risk-Based Testing Strategy

### Priority 1: High Risk Tests

| Test | Purpose | Type |
|------|---------|------|
| Signal chain integration | Verify filters_applied → chart update | Integration |
| DataFrame copy verification | Ensure filtered_df is independent | Unit |
| AND logic correctness | Multiple filters combine properly | Unit |

### Priority 2: Medium Risk Tests

| Test | Purpose | Type |
|------|---------|------|
| Widget cleanup | Add/remove filters, check memory | Widget |
| Performance benchmark | 100k rows < 500ms | Performance |
| Type checking | mypy passes | Static |

### Priority 3: Low Risk Tests

| Test | Purpose | Type |
|------|---------|------|
| Validation messages | Error text is clear | Unit |
| Input validation | Non-numeric rejected | Widget |

## Risk Acceptance Criteria

### Must Fix Before Production

- None (no critical risks)

### Must Monitor Post-Implementation

- TECH-001: Verify signal chain logging in debug builds
- DATA-001: Verify copy behavior in code review

### Accepted Risks

- SEC-001: Internal desktop app, no external attack surface

## Monitoring Requirements

Post-deployment monitoring for:

- Filter operation timing (debug log)
- Memory usage with many filter add/remove cycles
- Error rate in filter validation

## Risk Review Triggers

Review and update risk profile when:

- Filter operations extend beyond bounds filtering (e.g., text filters)
- Data size targets increase beyond 100k rows
- External data sources are added
- Multi-threading is introduced

---

Risk profile: docs/qa/assessments/2.2-risk-20260110.md
