# Test Design: Story 6.3

Date: 2026-01-13
Designer: Quinn (Test Architect)

## Test Strategy Overview

- Total test scenarios: 20
- Unit tests: 8 (40%)
- Integration/Widget tests: 12 (60%)
- E2E tests: 0 (0%) - Not required for local file I/O feature
- Priority distribution: P0: 6, P1: 10, P2: 4

## Test Scenarios by Acceptance Criteria

### AC1: Save button opens file dialog to save current bin configuration as JSON

| ID            | Level  | Priority | Test                                          | Justification                              |
|---------------|--------|----------|-----------------------------------------------|-------------------------------------------|
| 6.3-WIDG-001  | Widget | P1       | Save Config button exists in sidebar          | UI element verification                    |
| 6.3-WIDG-002  | Widget | P1       | Save button is enabled when bins configured   | Functional readiness                       |
| 6.3-WIDG-003  | Widget | P2       | Save button disabled when no bins exist       | Edge case - prevent empty saves            |

### AC2: Load button opens file dialog to load a previously saved bin configuration

| ID            | Level  | Priority | Test                                          | Justification                              |
|---------------|--------|----------|-----------------------------------------------|-------------------------------------------|
| 6.3-WIDG-004  | Widget | P1       | Load Config button exists in sidebar          | UI element verification                    |
| 6.3-WIDG-005  | Widget | P1       | Load button is always enabled                 | User can always attempt to load            |

### AC3: Configuration file includes: column name, all bin definitions, and metric selection

| ID            | Level | Priority | Test                                          | Justification                              | Mitigates |
|---------------|-------|----------|-----------------------------------------------|-------------------------------------------|-----------|
| 6.3-UNIT-001  | Unit  | P0       | to_dict() produces JSON-serializable dict     | Core serialization - data integrity        | DATA-002  |
| 6.3-UNIT-002  | Unit  | P0       | to_dict() includes column field               | Required field verification                | DATA-002  |
| 6.3-UNIT-003  | Unit  | P0       | to_dict() includes all bin definitions        | Required field verification                | DATA-002  |
| 6.3-UNIT-004  | Unit  | P0       | to_dict() includes metric_column field        | Required field verification                | DATA-002  |
| 6.3-UNIT-005  | Unit  | P1       | Round-trip serialization preserves all data   | Data integrity through save/load cycle     | DATA-002  |

### AC4: Loading a configuration populates the column dropdown, bin rows, and metric toggle

| ID            | Level  | Priority | Test                                          | Justification                              | Mitigates |
|---------------|--------|----------|-----------------------------------------------|-------------------------------------------|-----------|
| 6.3-WIDG-006  | Widget | P0       | _apply_config() sets column dropdown          | UI state sync - primary field              | TECH-001  |
| 6.3-WIDG-007  | Widget | P0       | _apply_config() creates correct number of bin rows | UI state sync - bin definitions       | TECH-001  |
| 6.3-WIDG-008  | Widget | P1       | _apply_config() sets metric toggle correctly  | UI state sync - metric selection           | TECH-001  |
| 6.3-WIDG-009  | Widget | P1       | bin_config_changed signal emits after load    | Signal-based architecture compliance       | TECH-001  |
| 6.3-WIDG-010  | Widget | P1       | _get_current_config() returns correct BinConfig | Symmetry with _apply_config()            | TECH-001  |

### AC5: Invalid configuration files show an error toast without crashing

| ID            | Level  | Priority | Test                                          | Justification                              | Mitigates |
|---------------|--------|----------|-----------------------------------------------|-------------------------------------------|-----------|
| 6.3-UNIT-006  | Unit   | P1       | from_dict() raises KeyError for missing column | Error detection - missing required field  | DATA-001  |
| 6.3-UNIT-007  | Unit   | P1       | from_dict() raises KeyError for missing bins  | Error detection - missing required field   | DATA-001  |
| 6.3-UNIT-008  | Unit   | P1       | validate() returns error for empty column     | Validation coverage                        | TECH-002  |
| 6.3-UNIT-009  | Unit   | P1       | validate() returns error for empty bins list  | Validation coverage                        | TECH-002  |
| 6.3-UNIT-010  | Unit   | P2       | validate() returns error for invalid metric   | Validation coverage                        | TECH-002  |
| 6.3-WIDG-011  | Widget | P1       | Loading column not in dataset shows error toast | User feedback for TECH-003 mitigation    | TECH-003  |

### AC6: Save/Load operations show loading feedback during file I/O

| ID            | Level  | Priority | Test                                          | Justification                              |
|---------------|--------|----------|-----------------------------------------------|-------------------------------------------|
| 6.3-WIDG-012  | Widget | P2       | Save operation shows feedback (cursor/button) | UX verification - visual feedback          |

### AC7: File dialog remembers last used directory within the session

| ID            | Level  | Priority | Test                                          | Justification                              | Mitigates |
|---------------|--------|----------|-----------------------------------------------|-------------------------------------------|-----------|
| 6.3-WIDG-013  | Widget | P2       | _last_save_dir updated after save             | Session state verification                 | BUS-001   |
| 6.3-WIDG-014  | Widget | P2       | Second dialog uses remembered directory       | UX convenience verification                | BUS-001   |

## Risk Coverage

| Risk ID   | Score | Covered By Tests                        | Coverage Level |
|-----------|-------|----------------------------------------|----------------|
| TECH-003  | 6     | 6.3-WIDG-011                           | Direct         |
| DATA-001  | 4     | 6.3-UNIT-006, 6.3-UNIT-007            | Direct         |
| TECH-001  | 4     | 6.3-WIDG-006 to 6.3-WIDG-010          | Comprehensive  |
| DATA-002  | 3     | 6.3-UNIT-001 to 6.3-UNIT-005          | Comprehensive  |
| BUS-001   | 3     | 6.3-WIDG-013, 6.3-WIDG-014            | Direct         |
| TECH-002  | 2     | 6.3-UNIT-008 to 6.3-UNIT-010          | Comprehensive  |
| OPS-001   | 1     | N/A - Handled by QFileDialog           | N/A            |
| DATA-003  | 1     | 6.3-UNIT-010                           | Indirect       |

## Test Implementation Mapping

### Unit Tests (tests/unit/test_binning_engine.py)

```python
# 6.3-UNIT-001: to_dict produces JSON-serializable dict
def test_bin_config_to_dict_serializable():
    """to_dict produces JSON-serializable output."""
    bins = [BinDefinition(operator="<", value1=100, label="Low")]
    config = BinConfig(column="volume", bins=bins, metric_column="gain_pct")
    result = config.to_dict()
    import json
    json.dumps(result)  # Should not raise

# 6.3-UNIT-002: to_dict includes column field
def test_bin_config_to_dict_includes_column():
    """to_dict includes column field."""
    config = BinConfig(column="volume", bins=[...], metric_column="gain_pct")
    assert config.to_dict()["column"] == "volume"

# 6.3-UNIT-003: to_dict includes all bin definitions
def test_bin_config_to_dict_includes_bins():
    """to_dict includes all bin definitions."""
    bins = [
        BinDefinition(operator="<", value1=100),
        BinDefinition(operator=">", value1=1000),
    ]
    config = BinConfig(column="volume", bins=bins, metric_column="gain_pct")
    result = config.to_dict()
    assert len(result["bins"]) == 2
    assert result["bins"][0]["operator"] == "<"
    assert result["bins"][1]["operator"] == ">"

# 6.3-UNIT-004: to_dict includes metric_column field
def test_bin_config_to_dict_includes_metric():
    """to_dict includes metric_column field."""
    config = BinConfig(column="volume", bins=[...], metric_column="adjusted_gain_pct")
    assert config.to_dict()["metric_column"] == "adjusted_gain_pct"

# 6.3-UNIT-005: Round-trip serialization
def test_bin_config_roundtrip():
    """Round-trip serialization preserves all data."""
    bins = [
        BinDefinition(operator="<", value1=100, label="Low"),
        BinDefinition(operator="range", value1=100, value2=1000, label="Mid"),
    ]
    original = BinConfig(column="volume", bins=bins, metric_column="adjusted_gain_pct")
    restored = BinConfig.from_dict(original.to_dict())
    assert restored.column == original.column
    assert len(restored.bins) == len(original.bins)
    assert restored.metric_column == original.metric_column

# 6.3-UNIT-006: from_dict raises KeyError for missing column
def test_bin_config_from_dict_missing_column():
    """from_dict raises KeyError for missing column."""
    data = {"bins": [], "metric_column": "gain_pct"}
    with pytest.raises(KeyError):
        BinConfig.from_dict(data)

# 6.3-UNIT-007: from_dict raises KeyError for missing bins
def test_bin_config_from_dict_missing_bins():
    """from_dict raises KeyError for missing bins."""
    data = {"column": "volume", "metric_column": "gain_pct"}
    with pytest.raises(KeyError):
        BinConfig.from_dict(data)

# 6.3-UNIT-008: validate catches empty column
def test_bin_config_validate_empty_column():
    """validate returns error for empty column."""
    config = BinConfig(column="", bins=[...], metric_column="gain_pct")
    errors = config.validate()
    assert any("column" in e.lower() for e in errors)

# 6.3-UNIT-009: validate catches empty bins
def test_bin_config_validate_empty_bins():
    """validate returns error for empty bins list."""
    config = BinConfig(column="volume", bins=[], metric_column="gain_pct")
    errors = config.validate()
    assert any("bin" in e.lower() for e in errors)

# 6.3-UNIT-010: validate catches invalid metric
def test_bin_config_validate_invalid_metric():
    """validate returns error for invalid metric_column."""
    config = BinConfig(column="volume", bins=[...], metric_column="invalid")
    errors = config.validate()
    assert any("metric" in e.lower() for e in errors)
```

### Widget Tests (tests/widget/test_data_binning.py)

```python
# 6.3-WIDG-001: Save button exists
def test_save_button_exists(qtbot, sample_dataframe, mock_app_state):
    """Save Config button exists in sidebar."""
    tab = DataBinningTab(mock_app_state)
    qtbot.addWidget(tab)
    save_btn = tab.findChild(QPushButton, "save_config_btn")
    assert save_btn is not None
    assert "Save" in save_btn.text()

# 6.3-WIDG-004: Load button exists
def test_load_button_exists(qtbot, sample_dataframe, mock_app_state):
    """Load Config button exists in sidebar."""
    tab = DataBinningTab(mock_app_state)
    qtbot.addWidget(tab)
    load_btn = tab.findChild(QPushButton, "load_config_btn")
    assert load_btn is not None
    assert "Load" in load_btn.text()

# 6.3-WIDG-006: _apply_config sets column dropdown
def test_apply_config_sets_column(qtbot, sample_dataframe, mock_app_state):
    """_apply_config correctly sets column dropdown."""
    tab = DataBinningTab(mock_app_state)
    qtbot.addWidget(tab)
    bins = [BinDefinition(operator="<", value1=100, label="Low")]
    config = BinConfig(column="volume", bins=bins, metric_column="gain_pct")
    tab._apply_config(config)
    assert tab._column_dropdown.currentText() == "volume"

# 6.3-WIDG-007: _apply_config creates bin rows
def test_apply_config_creates_bin_rows(qtbot, sample_dataframe, mock_app_state):
    """_apply_config creates correct number of bin rows."""
    tab = DataBinningTab(mock_app_state)
    qtbot.addWidget(tab)
    bins = [
        BinDefinition(operator="<", value1=100),
        BinDefinition(operator=">", value1=1000),
    ]
    config = BinConfig(column="volume", bins=bins, metric_column="gain_pct")
    tab._apply_config(config)
    assert len(tab._bin_rows) == 2

# 6.3-WIDG-009: Signal emits after load
def test_apply_config_emits_signal(qtbot, sample_dataframe, mock_app_state):
    """bin_config_changed signal emits after load completes."""
    tab = DataBinningTab(mock_app_state)
    qtbot.addWidget(tab)
    bins = [BinDefinition(operator="<", value1=100)]
    config = BinConfig(column="volume", bins=bins, metric_column="gain_pct")
    with qtbot.waitSignal(tab.bin_config_changed, timeout=1000):
        tab._apply_config(config)

# 6.3-WIDG-010: _get_current_config returns correct BinConfig
def test_get_current_config(qtbot, sample_dataframe, mock_app_state):
    """_get_current_config returns correct BinConfig."""
    tab = DataBinningTab(mock_app_state)
    qtbot.addWidget(tab)
    # Set up some state, then verify
    tab._column_dropdown.setCurrentText("volume")
    tab._add_bin_row(BinDefinition(operator="<", value1=100))
    config = tab._get_current_config()
    assert config.column == "volume"
    assert len(config.bins) == 1
```

## Recommended Execution Order

1. **P0 Unit tests** (fail fast on data integrity)
   - 6.3-UNIT-001 to 6.3-UNIT-004
2. **P0 Widget tests** (core functionality)
   - 6.3-WIDG-006, 6.3-WIDG-007
3. **P1 Unit tests** (error handling)
   - 6.3-UNIT-005 to 6.3-UNIT-009
4. **P1 Widget tests** (UI completeness)
   - 6.3-WIDG-001, 6.3-WIDG-004, 6.3-WIDG-008 to 6.3-WIDG-011
5. **P2 tests** (edge cases and UX)
   - 6.3-UNIT-010, 6.3-WIDG-002, 6.3-WIDG-003, 6.3-WIDG-012 to 6.3-WIDG-014

## Quality Checklist

- [x] Every AC has test coverage (AC1-7 all covered)
- [x] Test levels are appropriate (unit for logic, widget for UI)
- [x] No duplicate coverage across levels (unit tests logic, widget tests UI state)
- [x] Priorities align with business risk (data integrity = P0, error handling = P1)
- [x] Test IDs follow naming convention (6.3-UNIT-XXX, 6.3-WIDG-XXX)
- [x] Scenarios are atomic and independent (each test self-contained)

---
Test design matrix: docs/qa/assessments/6.3-test-design-20260113.md
P0 tests identified: 6
