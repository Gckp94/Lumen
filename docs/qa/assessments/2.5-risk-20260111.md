# Risk Profile: Story 2.5

Date: 2026-01-11
Reviewer: Quinn (Test Architect)

## Executive Summary

- Total Risks Identified: 6
- Critical Risks: 0
- High Risks: 0
- Risk Score: 79/100 (Low Risk)

## Risk Matrix

| Risk ID   | Description                          | Probability | Impact     | Score | Priority |
|-----------|--------------------------------------|-------------|------------|-------|----------|
| TECH-001  | Signal chain complexity              | Medium (2)  | Medium (2) | 4     | Medium   |
| TECH-002  | Component state synchronization      | Medium (2)  | Medium (2) | 4     | Medium   |
| DATA-001  | Date type handling inconsistency     | Medium (2)  | Medium (2) | 4     | Medium   |
| PERF-001  | Filter chain performance degradation | Low (1)     | High (3)   | 3     | Low      |
| TECH-003  | Duplicate prevention edge cases      | Medium (2)  | Low (1)    | 2     | Low      |
| OPS-001   | Test coverage complexity             | Low (1)     | Medium (2) | 2     | Low      |

## Detailed Risk Analysis

### Medium Priority Risks (Score 4)

#### TECH-001: Signal Chain Complexity

**Score: 4 (Medium)**

**Description**: The date range filter introduces a complex signal chain:
- DateRangeFilter.date_range_changed → FilterPanel → FeatureExplorerTab → FilterEngine.apply_date_range()

Multiple signal connections must be wired correctly, and any break in the chain causes silent failures.

**Probability**: Medium (2) - Standard PyQt6 signal/slot pattern, but involves 4 components

**Impact**: Medium (2) - Broken signals cause filters to not apply without error messages

**Affected Components**:
- `src/ui/components/date_range_filter.py` (NEW)
- `src/ui/components/filter_panel.py`
- `src/tabs/feature_explorer.py`
- `src/core/filter_engine.py`

**Mitigation**:
- Strategy: Preventive
- Actions:
  - Add DEBUG level logging at each signal emission point
  - Unit test signal emissions with `qtbot.waitSignal()`
  - Integration test full signal chain end-to-end
- Testing Requirements:
  - Unit tests for DateRangeFilter signal emission
  - Widget test for FilterPanel signal relay
  - Integration test for complete filter workflow
- Residual Risk: Low - Comprehensive test coverage

---

#### TECH-002: Component State Synchronization

**Score: 4 (Medium)**

**Description**: Multiple state sources must stay synchronized:
- FilterPanel: `_date_start`, `_date_end`, `_all_dates`, `_filter_rows`, `_active_filters`
- FeatureExplorerTab: Local date range state, AppState.filters
- DateRangeFilter: Internal widget state

State divergence can cause UI to show incorrect filter status.

**Probability**: Medium (2) - Multiple state locations is a common source of bugs

**Impact**: Medium (2) - User confusion, incorrect data displayed

**Affected Components**:
- `src/ui/components/filter_panel.py`
- `src/ui/components/date_range_filter.py`
- `src/tabs/feature_explorer.py`

**Mitigation**:
- Strategy: Preventive
- Actions:
  - Single source of truth: FilterPanel owns all filter state
  - Clear All button must reset all state atomically
  - Emit consolidated signals after state changes complete
- Testing Requirements:
  - Widget test: Clear All resets all state
  - Widget test: State consistency after add/remove filters
- Residual Risk: Low - Clear ownership model

---

#### DATA-001: Date Type Handling Inconsistency

**Score: 4 (Medium)**

**Description**: The apply_date_range() method must handle multiple date types:
- pandas datetime64[ns]
- Python date objects from QDateEdit
- Potentially string dates in source data

Type mismatches can cause silent filtering failures or exceptions.

**Probability**: Medium (2) - Real-world data often has mixed date formats

**Impact**: Medium (2) - Silent incorrect results or runtime errors

**Affected Components**:
- `src/core/filter_engine.py`

**Mitigation**:
- Strategy: Preventive
- Actions:
  - Always use `pd.to_datetime()` for conversion
  - Use `pd.Timestamp()` for comparison values
  - Add explicit type handling in apply_date_range()
- Testing Requirements:
  - Unit test with datetime64 column
  - Unit test with date object inputs
  - Unit test with mixed date formats in source data
- Residual Risk: Low - pandas handles most conversions gracefully

---

### Low Priority Risks (Score 2-3)

#### PERF-001: Filter Chain Performance Degradation

**Score: 3 (Low)**

**Description**: NFR requires 10 filters + date range complete in < 500ms for 100k rows. Adding date parsing (`pd.to_datetime()`) on each filter operation could add overhead.

**Probability**: Low (1) - pandas vectorized operations are highly optimized

**Impact**: High (3) - NFR failure blocks release

**Mitigation**:
- Strategy: Detective + Preventive
- Actions:
  - Benchmark apply_date_range() in isolation
  - Consider caching parsed date column if repeated filtering
  - Integration test with 100k row dataset
- Testing Requirements:
  - Performance integration test with timing assertions
- Residual Risk: Low - pandas typically handles 100k rows in milliseconds

---

#### TECH-003: Duplicate Prevention Edge Cases

**Score: 2 (Low)**

**Description**: Edge cases in duplicate column prevention:
- What happens when user changes column in existing filter row?
- Does column become available again when row is removed?
- What if all columns are used?

**Probability**: Medium (2) - Edge cases require explicit handling

**Impact**: Low (1) - Minor UX issue, not data corruption

**Mitigation**:
- Strategy: Preventive
- Actions:
  - Track column changes with column_changed signal
  - Rebuild available columns on any filter row change
  - Disable Add button when no columns available
- Testing Requirements:
  - Widget test: Column reuse after removal
  - Widget test: No columns available state
- Residual Risk: Minimal

---

#### OPS-001: Test Coverage Complexity

**Score: 2 (Low)**

**Description**: Story defines 13 test tasks across unit/widget/integration levels. Ensuring complete coverage requires discipline.

**Probability**: Low (1) - Test tasks are well-defined in story

**Impact**: Medium (2) - Gaps could allow regressions

**Mitigation**:
- Strategy: Detective
- Actions:
  - Run `make test` with coverage reporting
  - Review coverage report before marking story complete
- Testing Requirements: N/A (meta-risk about testing itself)
- Residual Risk: Low - CI enforces test execution

---

## Risk Distribution

### By Category

| Category    | Count | Medium | Low |
|-------------|-------|--------|-----|
| Technical   | 3     | 2      | 1   |
| Data        | 1     | 1      | 0   |
| Performance | 1     | 0      | 1   |
| Operational | 1     | 0      | 1   |
| Security    | 0     | 0      | 0   |
| Business    | 0     | 0      | 0   |

### By Component

| Component                | Risks |
|--------------------------|-------|
| DateRangeFilter (NEW)    | 2     |
| FilterPanel              | 3     |
| FilterEngine             | 2     |
| FeatureExplorerTab       | 2     |

## Risk-Based Testing Strategy

### Priority 1: Medium Risk Tests

1. **Signal Chain Integration Test**
   - Test complete flow: DateRangeFilter → FilterPanel → Tab → Engine
   - Verify data actually filtered correctly

2. **State Synchronization Tests**
   - Clear All resets everything
   - Adding/removing filters updates available columns

3. **Date Type Handling Tests**
   - datetime64 columns
   - Python date inputs
   - Edge cases (None start, None end)

### Priority 2: Low Risk Tests

4. **Performance Test**
   - 10 filters + date range on 100k rows < 500ms

5. **Duplicate Prevention Edge Cases**
   - Column availability updates
   - All columns used state

### Priority 3: Standard Coverage

6. **All remaining unit and widget tests per story tasks**

## Risk Acceptance Criteria

### Must Fix Before Production

- None (no critical or high risks)

### Can Deploy with Mitigation

- All medium risks (score 4) with test coverage in place

### Accepted Risks

- All low risks (score 2-3) with monitoring

## Monitoring Requirements

Post-deployment monitoring:

- **Performance**: Track filter operation times in debug log
- **Errors**: Monitor for date parsing exceptions
- **UX**: Watch for user reports of filter confusion

## Integration with Quality Gates

**Gate Determination**: PASS

- No risks with score ≥ 9 (Critical)
- No risks with score ≥ 6 (High)
- All risks are Medium (4) or Low (2-3)

---

## Gate YAML Block

```yaml
# risk_summary (paste into gate file):
risk_summary:
  totals:
    critical: 0
    high: 0
    medium: 3
    low: 3
  highest:
    id: TECH-001
    score: 4
    title: 'Signal chain complexity'
  recommendations:
    must_fix: []
    monitor:
      - 'Add DEBUG logging for signal emissions'
      - 'Track filter operation times'
```

---

Risk profile: docs/qa/assessments/2.5-risk-20260111.md
