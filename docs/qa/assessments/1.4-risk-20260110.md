# Risk Profile: Story 1.4 - Column Configuration Panel

Date: 2026-01-10
Reviewer: Quinn (Test Architect)

## Executive Summary

- **Total Risks Identified:** 10
- **Critical Risks:** 0
- **High Risks:** 0
- **Medium Risks:** 2
- **Low Risks:** 5
- **Minimal Risks:** 3
- **Risk Score:** 80/100 (Low-Medium Risk)

This story presents a manageable risk profile. The primary concerns center around auto-detection accuracy and cache staleness, both of which can be mitigated through comprehensive testing.

## Risk Matrix

| Risk ID   | Description                                      | Probability | Impact     | Score | Priority |
|-----------|--------------------------------------------------|-------------|------------|-------|----------|
| TECH-001  | Pattern matching false positives/negatives       | Medium (2)  | Medium (2) | 4     | Medium   |
| DATA-002  | Stale cache after file content changes           | Medium (2)  | Medium (2) | 4     | Medium   |
| DATA-003  | Validation bypass allowing invalid mapping       | Low (1)     | High (3)   | 3     | Low      |
| TECH-002  | Integration dependency on Story 1.3 signal       | Low (1)     | Medium (2) | 2     | Low      |
| TECH-003  | Widget state complexity (interdependent controls)| Medium (2)  | Low (1)    | 2     | Low      |
| DATA-001  | Cache file corruption (malformed JSON)           | Low (1)     | Medium (2) | 2     | Low      |
| BUS-001   | User confusion: detected vs guessed status       | Medium (2)  | Low (1)    | 2     | Low      |
| SEC-001   | MD5 hash collision for cache keys                | Low (1)     | Low (1)    | 1     | Minimal  |
| PERF-001  | Large DataFrame column enumeration               | Low (1)     | Low (1)    | 1     | Minimal  |
| OPS-001   | Cache directory creation failure                 | Low (1)     | Low (1)    | 1     | Minimal  |

## Detailed Risk Register

### TECH-001: Pattern Matching False Positives/Negatives

**Score: 4 (Medium)**

**Description:** The `auto_detect()` function uses case-insensitive substring matching against predefined patterns. This may:
- Match wrong columns (e.g., "timestamp" matches "time" pattern but may be wrong column)
- Miss valid columns with non-standard names (e.g., "pct_change" for gain)

**Probability:** Medium - Common data files have varied naming conventions.

**Impact:** Medium - Wrong mappings lead to incorrect analysis, but user can correct via config panel.

**Mitigation Strategy:**
- Implement "guessed" vs "detected" distinction based on match confidence
- Use status indicators (guessed = amber) to alert users
- Show preview values to help user verify correctness
- Test with diverse real-world column naming patterns

**Testing Requirements:**
- Unit tests for pattern matching edge cases
- Integration tests with various CSV/Excel files
- Manual testing with real trading data files

---

### DATA-002: Stale Cache After File Content Changes

**Score: 4 (Medium)**

**Description:** Cache key uses MD5 hash of file path (not content). If user modifies file content but keeps same path, cached mapping may become invalid.

**Probability:** Medium - Users may edit source files between sessions.

**Impact:** Medium - Stale mapping could cause analysis errors, but validation catches missing columns.

**Mitigation Strategy:**
- Document that cache is path-based (user expectation)
- Validation step catches missing columns (fails fast)
- Consider adding file modification timestamp to cache key (future enhancement)

**Testing Requirements:**
- Test load_mapping returns cached value for same path
- Test validation catches when cached column no longer exists

---

### DATA-003: Validation Bypass Allowing Invalid Mapping

**Score: 3 (Low)**

**Description:** If validation logic has bugs, invalid mappings (missing required columns, duplicates) could proceed to analysis.

**Probability:** Low - Straightforward validation logic.

**Impact:** High - Invalid mapping causes analysis failures or incorrect results.

**Mitigation Strategy:**
- Comprehensive unit tests for `ColumnMapping.validate()`
- Test duplicate column detection
- Test all required fields checked
- Disable "Continue" button until validation passes

**Testing Requirements:**
- Unit tests for all validation error conditions
- Widget tests for button state tied to validation

---

### TECH-002: Integration Dependency on Story 1.3

**Score: 2 (Low)**

**Description:** Story 1.4 depends on `data_loaded` signal from Story 1.3. If signal contract changes, integration breaks.

**Probability:** Low - Signal interface is documented.

**Impact:** Medium - Workflow breaks if signal not emitted correctly.

**Mitigation Strategy:**
- Integration test that verifies signal triggers column detection
- Document signal contract in Dev Notes

**Testing Requirements:**
- Integration test: file load -> signal -> auto_detect called

---

### TECH-003: Widget State Complexity

**Score: 2 (Low)**

**Description:** Multiple interdependent UI elements: "Derive Win/Loss" checkbox toggles dropdown visibility; breakeven checkbox only visible when deriving.

**Probability:** Medium - State logic can have edge cases.

**Impact:** Low - UI glitches, not data corruption.

**Mitigation Strategy:**
- Clear state machine for widget visibility
- Widget tests for all state transitions

**Testing Requirements:**
- Widget tests for checkbox toggle behaviors
- Test visibility of breakeven checkbox in both states

---

### DATA-001: Cache File Corruption

**Score: 2 (Low)**

**Description:** Malformed JSON in `.lumen_cache/{hash}_mappings.json` could crash load_mapping.

**Probability:** Low - JSON serialization is reliable.

**Impact:** Medium - Application error, but recoverable.

**Mitigation Strategy:**
- Try/except around JSON parsing
- Return None on parse error (fall back to auto-detect)
- Log warning for corrupted cache

**Testing Requirements:**
- Unit test for corrupted cache file handling

---

### BUS-001: User Confusion with Status Indicators

**Score: 2 (Low)**

**Description:** Users may not understand difference between "detected" (high confidence) and "guessed" (low confidence) status indicators.

**Probability:** Medium - New users unfamiliar with system.

**Impact:** Low - User experience issue, not functional failure.

**Mitigation Strategy:**
- Clear visual distinction (cyan vs amber)
- Preview values help user verify
- Consider tooltip explanations

**Testing Requirements:**
- Visual verification of status indicators
- User acceptance testing

---

### SEC-001: MD5 Hash Collision

**Score: 1 (Minimal)**

**Description:** Theoretical MD5 collision could cause wrong cached mapping to load.

**Probability:** Low - Extremely unlikely for file paths.

**Impact:** Low - Wrong mapping, user would notice incorrect data.

**Mitigation Strategy:**
- Accept risk (probability negligible for this use case)
- Consider SHA-256 if security requirements increase

---

### PERF-001: Large DataFrame Column Enumeration

**Score: 1 (Minimal)**

**Description:** DataFrames with many columns (100+) could slow dropdown population.

**Probability:** Low - Trading data typically has <20 columns.

**Impact:** Low - Minor UI delay.

**Mitigation Strategy:**
- No action needed for MVP
- Consider lazy loading if issue reported

---

### OPS-001: Cache Directory Creation Failure

**Score: 1 (Minimal)**

**Description:** `.lumen_cache/` directory creation could fail due to permissions.

**Probability:** Low - Standard user directory operations.

**Impact:** Low - Caching disabled, functionality continues.

**Mitigation Strategy:**
- Create directory on save with error handling
- Log warning if creation fails
- Continue without caching

---

## Risk Distribution

### By Category
- Technical: 3 risks (0 critical, 0 high)
- Data: 3 risks (0 critical, 0 high)
- Security: 1 risk (0 critical, 0 high)
- Performance: 1 risk (0 critical, 0 high)
- Business: 1 risk (0 critical, 0 high)
- Operational: 1 risk (0 critical, 0 high)

### By Component
- Core Logic (ColumnMapper): 3 risks
- Data Model (ColumnMapping): 1 risk
- UI (ColumnConfigPanel): 2 risks
- Cache System: 3 risks
- Integration: 1 risk

## Risk-Based Testing Strategy

### Priority 1: Medium Risk Tests
- Pattern matching accuracy (TECH-001)
  - Boundary cases for substring matching
  - Case sensitivity tests
  - Multiple match resolution
- Cache staleness detection (DATA-002)
  - Validation catches renamed/removed columns

### Priority 2: Low Risk Tests
- Validation completeness (DATA-003)
- Widget state transitions (TECH-003)
- Integration signal flow (TECH-002)
- Cache corruption handling (DATA-001)

### Priority 3: Minimal Risk Tests
- Standard functional tests cover remaining risks

## Risk Acceptance Criteria

### Must Fix Before Production
- None (no critical or high risks)

### Can Deploy with Mitigation
- All identified risks have acceptable mitigations in place
- Testing coverage addresses primary concerns

### Accepted Risks
- SEC-001 (MD5 collision): Accepted - probability negligible
- PERF-001 (large DataFrames): Accepted - out of scope for typical use

## Monitoring Requirements

Post-deployment monitoring for:
- Error rates on column mapping failures
- User correction rate (how often users change auto-detected values)
- Cache hit/miss ratio

## Risk Review Triggers

Review and update risk profile when:
- Auto-detection patterns are expanded
- Cache strategy changes
- Integration with additional data sources added
