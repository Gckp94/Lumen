# Test Design: Story 2.5

Date: 2026-01-11
Designer: Quinn (Test Architect)

## Test Strategy Overview

- Total test scenarios: 24
- Unit tests: 12 (50%)
- Widget tests: 8 (33%)
- Integration tests: 4 (17%)
- Priority distribution: P0: 10, P1: 9, P2: 5

## Test Scenarios by Acceptance Criteria

### AC1: Support up to 10 simultaneous filters with AND logic

| ID            | Level       | Priority | Test                                    | Justification                        |
|---------------|-------------|----------|-----------------------------------------|--------------------------------------|
| 2.5-UNIT-001  | Unit        | P0       | FilterEngine applies AND logic          | Core filtering logic verification    |
| 2.5-UNIT-002  | Unit        | P1       | FilterEngine handles empty filter list  | Edge case: no filters applied        |
| 2.5-INT-001   | Integration | P0       | 10 filters combine correctly            | Full filter chain validation         |
| 2.5-INT-002   | Integration | P0       | Filter order doesn't affect results     | AND logic is commutative             |

**Test Details:**

```python
# 2.5-UNIT-001: FilterEngine applies AND logic
def test_filter_engine_and_logic(sample_trades):
    """All filters applied with AND - rows must match ALL criteria."""
    engine = FilterEngine()
    filters = [
        FilterCriteria(column="gain_pct", operator="between", min_val=0, max_val=10),
        FilterCriteria(column="volume", operator="between", min_val=100, max_val=1000),
    ]
    result = engine.apply_filters(sample_trades, filters)
    assert all(result["gain_pct"].between(0, 10))
    assert all(result["volume"].between(100, 1000))

# 2.5-INT-001: 10 filters combine correctly
def test_ten_filters_applied(large_dataset):
    """NFR: System supports 10 simultaneous filters."""
    engine = FilterEngine()
    filters = [FilterCriteria(column=f"col_{i}", ...) for i in range(10)]
    result = engine.apply_filters(large_dataset, filters)
    # Verify all 10 filter conditions met
```

---

### AC2: No duplicate columns (replace existing)

| ID            | Level  | Priority | Test                                      | Justification                     |
|---------------|--------|----------|-------------------------------------------|-----------------------------------|
| 2.5-UNIT-003  | Unit   | P1       | _get_used_columns returns correct set     | Helper method logic               |
| 2.5-WIDG-001  | Widget | P1       | Add filter excludes used columns          | UI dropdown behavior              |
| 2.5-WIDG-002  | Widget | P1       | Remove filter makes column available      | Column reuse after removal        |
| 2.5-WIDG-003  | Widget | P2       | Add button disabled when all cols used    | Edge case: no columns left        |

**Test Details:**

```python
# 2.5-WIDG-001: Add filter excludes used columns
def test_add_filter_excludes_used_columns(qtbot):
    """Adding filter excludes columns already in use."""
    panel = FilterPanel(columns=["gain_pct", "volume", "price"])
    qtbot.addWidget(panel)
    
    panel._on_add_filter()
    panel._filter_rows[0].set_column("gain_pct")
    
    panel._on_add_filter()
    available = panel._filter_rows[1].get_available_columns()
    assert "gain_pct" not in available
    assert "volume" in available

# 2.5-WIDG-002: Remove filter makes column available
def test_remove_filter_makes_column_available(qtbot):
    """Removing filter restores column to available list."""
    panel = FilterPanel(columns=["gain_pct", "volume"])
    qtbot.addWidget(panel)
    
    panel._on_add_filter()
    panel._filter_rows[0].set_column("gain_pct")
    panel._on_remove_row(panel._filter_rows[0])
    
    panel._on_add_filter()
    available = panel._filter_rows[0].get_available_columns()
    assert "gain_pct" in available
```

---

### AC3: Active filters displayed as chips with remove button

| ID            | Level  | Priority | Test                                | Justification                       |
|---------------|--------|----------|-------------------------------------|-------------------------------------|
| 2.5-WIDG-004  | Widget | P2       | Filter chips display for each filter| Regression test (from 2.4)          |
| 2.5-WIDG-005  | Widget | P2       | Remove chip removes filter          | Regression test (from 2.4)          |

**Note:** AC3 was implemented in Story 2.4. These are regression tests to ensure the feature still works after 2.5 modifications.

---

### AC4: Date range filter: start/end date pickers, "All Dates" checkbox

| ID            | Level       | Priority | Test                                      | Justification                     |
|---------------|-------------|----------|-------------------------------------------|-----------------------------------|
| 2.5-UNIT-004  | Unit        | P0       | DateRangeFilter emits signal on change    | Signal contract verification      |
| 2.5-UNIT-005  | Unit        | P0       | All Dates checkbox disables pickers       | UI state management               |
| 2.5-UNIT-006  | Unit        | P0       | apply_date_range with start and end       | Core date filtering logic         |
| 2.5-UNIT-007  | Unit        | P1       | apply_date_range with all_dates=True      | Returns unfiltered data           |
| 2.5-UNIT-008  | Unit        | P1       | apply_date_range with None start          | No lower bound                    |
| 2.5-UNIT-009  | Unit        | P1       | apply_date_range with None end            | No upper bound                    |
| 2.5-UNIT-010  | Unit        | P1       | apply_date_range handles datetime64       | Type compatibility                |
| 2.5-WIDG-006  | Widget      | P0       | DateRangeFilter UI initialization         | Default state verification        |
| 2.5-INT-003   | Integration | P0       | Date range + column filters combined      | Full filter chain                 |

**Test Details:**

```python
# 2.5-UNIT-004: DateRangeFilter emits signal on change
def test_date_range_filter_signal_emission(qtbot):
    """Signal emitted when date or checkbox changes."""
    widget = DateRangeFilter()
    qtbot.addWidget(widget)
    
    with qtbot.waitSignal(widget.date_range_changed) as blocker:
        widget._all_dates_checkbox.setChecked(False)
    
    start, end, all_dates = blocker.args
    assert all_dates is False
    assert start is not None
    assert end is not None

# 2.5-UNIT-006: apply_date_range with start and end
def test_date_range_filter_inclusive(sample_trades):
    """Date range includes boundary dates."""
    engine = FilterEngine()
    result = engine.apply_date_range(
        sample_trades,
        date_col="date",
        start=date(2024, 1, 15),
        end=date(2024, 1, 20),
    )
    dates = pd.to_datetime(result["date"])
    assert all(dates >= pd.Timestamp("2024-01-15"))
    assert all(dates <= pd.Timestamp("2024-01-20"))

# 2.5-INT-003: Date range + column filters combined
def test_date_range_plus_column_filters(sample_trades):
    """Date range and column filters combine correctly."""
    engine = FilterEngine()
    
    date_filtered = engine.apply_date_range(
        sample_trades, date_col="date",
        start=date(2024, 1, 10), end=date(2024, 1, 20),
    )
    
    criteria = FilterCriteria(column="gain_pct", operator="between", min_val=0, max_val=5)
    result = engine.apply_filters(date_filtered, [criteria])
    
    dates = pd.to_datetime(result["date"])
    assert all(dates >= pd.Timestamp("2024-01-10"))
    assert all(dates <= pd.Timestamp("2024-01-20"))
    assert all(result["gain_pct"].between(0, 5))
```

---

### AC5: Filter summary in bottom bar

| ID            | Level  | Priority | Test                                    | Justification                   |
|---------------|--------|----------|-----------------------------------------|---------------------------------|
| 2.5-WIDG-007  | Widget | P1       | Summary shows "Filters: None" initially | Default state                   |
| 2.5-WIDG-008  | Widget | P1       | Summary updates with filter count       | Dynamic update on filter add    |
| 2.5-UNIT-011  | Unit   | P2       | Summary format with date range only     | Text format verification        |
| 2.5-UNIT-012  | Unit   | P2       | Summary format with filters + date      | Combined format verification    |

**Test Details:**

```python
# 2.5-WIDG-007: Summary shows "Filters: None" initially
def test_filter_summary_initial_state(qtbot, feature_explorer_tab):
    """Filter summary shows 'Filters: None' on initial load."""
    assert feature_explorer_tab._filter_summary_label.text() == "Filters: None"

# 2.5-WIDG-008: Summary updates with filter count
def test_filter_summary_updates(qtbot, feature_explorer_tab):
    """Filter summary updates when filters applied."""
    # Apply 2 filters
    feature_explorer_tab._apply_filters([filter1, filter2])
    assert "2 active" in feature_explorer_tab._filter_summary_label.text()
```

---

### AC6: Filter chain applied in < 500ms for 100k rows

| ID            | Level       | Priority | Test                                    | Justification                   |
|---------------|-------------|----------|-----------------------------------------|---------------------------------|
| 2.5-INT-004   | Integration | P0       | 10 filters + date range < 500ms         | NFR performance requirement     |

**Test Details:**

```python
# 2.5-INT-004: 10 filters + date range < 500ms
@pytest.mark.slow
def test_ten_filters_performance(large_dataset_100k):
    """NFR: Filter chain completes in < 500ms for 100k rows."""
    from time import perf_counter
    
    engine = FilterEngine()
    
    # Date range filter
    start_time = perf_counter()
    date_filtered = engine.apply_date_range(
        large_dataset_100k, date_col="date",
        start=date(2024, 1, 1), end=date(2024, 6, 30),
    )
    
    # 10 column filters
    filters = [
        FilterCriteria(column=f"feature_{i}", operator="between", 
                      min_val=-10+i, max_val=10-i)
        for i in range(10)
    ]
    result = engine.apply_filters(date_filtered, filters)
    
    elapsed = perf_counter() - start_time
    assert elapsed < 0.5, f"Filter chain took {elapsed:.3f}s, exceeds 500ms limit"
```

---

## Risk Coverage Mapping

| Risk ID   | Test Scenarios                              |
|-----------|---------------------------------------------|
| TECH-001  | 2.5-UNIT-004, 2.5-INT-003                   |
| TECH-002  | 2.5-WIDG-001, 2.5-WIDG-002, 2.5-WIDG-006    |
| DATA-001  | 2.5-UNIT-006, 2.5-UNIT-007, 2.5-UNIT-010    |
| PERF-001  | 2.5-INT-004                                 |
| TECH-003  | 2.5-WIDG-002, 2.5-WIDG-003                  |
| OPS-001   | All tests (comprehensive coverage)          |

---

## Test File Mapping

| Test File                                    | Scenarios                                   |
|----------------------------------------------|---------------------------------------------|
| `tests/unit/test_filter_engine.py`           | 2.5-UNIT-001, 002, 006-010                  |
| `tests/unit/test_date_range_filter.py` (NEW) | 2.5-UNIT-003, 004, 005, 011, 012            |
| `tests/widget/test_filter_panel_duplicates.py` (NEW) | 2.5-WIDG-001, 002, 003            |
| `tests/widget/test_feature_explorer.py`      | 2.5-WIDG-004, 005, 006, 007, 008            |
| `tests/integration/test_filter_workflow.py`  | 2.5-INT-001, 002, 003, 004                  |

---

## Recommended Execution Order

1. **P0 Unit tests** (fail fast on core logic)
   - 2.5-UNIT-001, 004, 005, 006

2. **P0 Widget tests** (fail fast on UI)
   - 2.5-WIDG-006

3. **P0 Integration tests** (end-to-end validation)
   - 2.5-INT-001, 003, 004

4. **P1 tests in order**
   - Unit: 2.5-UNIT-002, 007, 008, 009, 010
   - Widget: 2.5-WIDG-001, 002, 007, 008

5. **P2 tests as time permits**
   - Widget: 2.5-WIDG-003, 004, 005
   - Unit: 2.5-UNIT-011, 012

---

## Quality Checklist

- [x] Every AC has test coverage
- [x] Test levels are appropriate (not over-testing)
- [x] No duplicate coverage across levels
- [x] Priorities align with business risk
- [x] Test IDs follow naming convention: {story}-{LEVEL}-{SEQ}
- [x] Scenarios are atomic and independent
- [x] Risk mitigations mapped to tests

---

## Gate YAML Block

```yaml
test_design:
  scenarios_total: 24
  by_level:
    unit: 12
    widget: 8
    integration: 4
  by_priority:
    p0: 10
    p1: 9
    p2: 5
  coverage_gaps: []
```

---

Test design matrix: docs/qa/assessments/2.5-test-design-20260111.md
P0 tests identified: 10
