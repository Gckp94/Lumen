# Test Design: Story 3.3

Date: 2026-01-11
Designer: Quinn (Test Architect)

## Test Strategy Overview

- Total test scenarios: 22
- Unit tests: 15 (68%)
- Widget tests: 5 (23%)
- Integration tests: 2 (9%)
- E2E tests: 0 (0%)
- Priority distribution: P0: 6, P1: 10, P2: 6

## Test Scenarios by Acceptance Criteria

### AC1: Calculate Max Consecutive Wins, Max Consecutive Losses, Max Loss %

#### Scenarios

| ID            | Level  | Priority | Test                                        | Justification                              | Mitigates |
|---------------|--------|----------|---------------------------------------------|--------------------------------------------|-----------|
| 3.3-UNIT-001  | Unit   | P0       | max_consecutive_wins with known streak      | Core algorithm correctness                 | TECH-001  |
| 3.3-UNIT-002  | Unit   | P0       | max_consecutive_losses with known streak    | Core algorithm correctness                 | TECH-001  |
| 3.3-UNIT-003  | Unit   | P0       | max_loss_pct returns worst loss             | Core calculation correctness               | TECH-001  |
| 3.3-UNIT-004  | Unit   | P1       | streaks_empty_dataframe returns None        | Edge case - no data                        | TECH-002  |
| 3.3-UNIT-005  | Unit   | P1       | streaks_all_winners                         | Edge case - all positive                   | TECH-002  |
| 3.3-UNIT-006  | Unit   | P1       | streaks_all_losers                          | Edge case - all negative                   | TECH-002  |
| 3.3-UNIT-007  | Unit   | P1       | streaks_alternating                         | Edge case - no streaks > 1                 | TECH-002  |
| 3.3-UNIT-008  | Unit   | P2       | streaks_single_trade_win                    | Edge case - single winner                  | TECH-002  |
| 3.3-UNIT-009  | Unit   | P2       | streaks_single_trade_loss                   | Edge case - single loser                   | TECH-002  |
| 3.3-UNIT-010  | Unit   | P2       | max_loss_pct_none_when_no_losers            | Edge case - all winners                    | DATA-002  |
| 3.3-WIDG-001  | Widget | P1       | metrics_grid_displays_streak_metrics        | UI correctly shows new fields              | DATA-002  |
| 3.3-WIDG-002  | Widget | P1       | streak_metrics_tooltips_present             | Tooltips provide user guidance             | -         |
| 3.3-WIDG-003  | Widget | P1       | max_loss_displays_coral_color               | Negative values styled correctly           | TECH-003  |

### AC2: Streak Detection on Chronologically Sorted Data

#### Scenarios

| ID            | Level  | Priority | Test                                        | Justification                              | Mitigates |
|---------------|--------|----------|---------------------------------------------|--------------------------------------------|-----------|
| 3.3-UNIT-011  | Unit   | P0       | chronological_sorting_affects_streaks       | Verify sorting changes streak results      | DATA-001  |
| 3.3-UNIT-012  | Unit   | P1       | sorting_with_date_time_columns              | Verify sort_values called with params      | DATA-001  |
| 3.3-UNIT-013  | Unit   | P2       | pre_sorted_data_unchanged                   | Data already sorted not re-sorted          | DATA-001  |

### AC3: Max Loss % Uses stop_loss User Input

#### Scenarios

| ID            | Level  | Priority | Test                                        | Justification                              | Mitigates |
|---------------|--------|----------|---------------------------------------------|--------------------------------------------|-----------|
| 3.3-UNIT-014  | Unit   | P0       | max_loss_pct_respects_stop_loss_adjustment  | Stop loss caps worst loss                  | TECH-004  |
| 3.3-UNIT-015  | Unit   | P1       | max_loss_pct_no_cap_when_below_stop_loss    | Losses below stop not affected             | TECH-004  |

### AC4: Recalculate on stop_loss Change

#### Scenarios

| ID            | Level       | Priority | Test                                        | Justification                              | Mitigates |
|---------------|-------------|----------|---------------------------------------------|--------------------------------------------|-----------|
| 3.3-INT-001   | Integration | P0       | recalculation_triggered_on_stop_loss_change | Verify signal chain triggers recalc        | TECH-004  |
| 3.3-INT-002   | Integration | P1       | metrics_update_after_adjustment_change      | MetricsGrid receives updated values        | TECH-004  |
| 3.3-WIDG-004  | Widget      | P2       | streak_metrics_update_on_signal             | Widget responds to update signal           | -         |
| 3.3-WIDG-005  | Widget      | P2       | debounced_recalculation                     | Multiple rapid changes debounced           | -         |

## Risk Coverage

| Risk ID   | Test IDs Mitigating                                     |
|-----------|---------------------------------------------------------|
| TECH-001  | 3.3-UNIT-001, 3.3-UNIT-002, 3.3-UNIT-003               |
| TECH-002  | 3.3-UNIT-004 through 3.3-UNIT-010                      |
| TECH-003  | 3.3-WIDG-003                                            |
| TECH-004  | 3.3-UNIT-014, 3.3-UNIT-015, 3.3-INT-001, 3.3-INT-002   |
| DATA-001  | 3.3-UNIT-011, 3.3-UNIT-012, 3.3-UNIT-013               |
| DATA-002  | 3.3-UNIT-010, 3.3-WIDG-001                             |

## Detailed Test Specifications

### Unit Tests (tests/unit/test_metrics.py)

#### 3.3-UNIT-001: max_consecutive_wins with known streak

```python
def test_max_consecutive_wins(streak_test_df):
    """Max consecutive wins = 3 (trades 1-3)."""
    calc = MetricsCalculator()
    metrics = calc.calculate(streak_test_df, "gain_pct")
    assert metrics.max_consecutive_wins == 3
```

**Test Data**: Sample from story (trades 1-10 with pattern WWWLLWLLLW)
**Expected**: max_consecutive_wins = 3

#### 3.3-UNIT-002: max_consecutive_losses with known streak

```python
def test_max_consecutive_losses(streak_test_df):
    """Max consecutive losses = 3 (trades 7-9)."""
    calc = MetricsCalculator()
    metrics = calc.calculate(streak_test_df, "gain_pct")
    assert metrics.max_consecutive_losses == 3
```

**Test Data**: Same sample, losses at positions 4-5, 7-9
**Expected**: max_consecutive_losses = 3

#### 3.3-UNIT-003: max_loss_pct returns worst loss

```python
def test_max_loss_pct(streak_test_df):
    """Max loss = -6.0% (trade 7, most negative)."""
    calc = MetricsCalculator()
    metrics = calc.calculate(streak_test_df, "gain_pct")
    assert metrics.max_loss_pct == pytest.approx(-6.0, abs=0.01)
```

**Test Data**: Losses [-2.0, -4.0, -6.0, -3.0, -5.0]
**Expected**: max_loss_pct = -6.0

#### 3.3-UNIT-004: streaks_empty_dataframe returns None

```python
def test_streaks_empty_dataframe():
    """Empty DataFrame returns None streaks."""
    calc = MetricsCalculator()
    empty_df = pd.DataFrame(columns=["gain_pct"])
    metrics = calc.calculate(empty_df, "gain_pct")
    assert metrics.max_consecutive_wins is None
    assert metrics.max_consecutive_losses is None
    assert metrics.max_loss_pct is None
```

#### 3.3-UNIT-005: streaks_all_winners

```python
def test_streaks_all_winners():
    """All winners: max wins = num_trades, max losses = 0."""
    calc = MetricsCalculator()
    df = pd.DataFrame({"gain_pct": [1.0, 2.0, 3.0, 4.0, 5.0]})
    metrics = calc.calculate(df, "gain_pct")
    assert metrics.max_consecutive_wins == 5
    assert metrics.max_consecutive_losses == 0
```

#### 3.3-UNIT-006: streaks_all_losers

```python
def test_streaks_all_losers():
    """All losers: max wins = 0, max losses = num_trades."""
    calc = MetricsCalculator()
    df = pd.DataFrame({"gain_pct": [-1.0, -2.0, -3.0, -4.0, -5.0]})
    metrics = calc.calculate(df, "gain_pct")
    assert metrics.max_consecutive_wins == 0
    assert metrics.max_consecutive_losses == 5
```

#### 3.3-UNIT-007: streaks_alternating

```python
def test_streaks_alternating():
    """Alternating W/L: max = 1 for both."""
    calc = MetricsCalculator()
    df = pd.DataFrame({"gain_pct": [1.0, -1.0, 1.0, -1.0]})
    metrics = calc.calculate(df, "gain_pct")
    assert metrics.max_consecutive_wins == 1
    assert metrics.max_consecutive_losses == 1
```

#### 3.3-UNIT-008: streaks_single_trade_win

```python
def test_streaks_single_trade_win():
    """Single winning trade: (1, 0)."""
    calc = MetricsCalculator()
    df = pd.DataFrame({"gain_pct": [5.0]})
    metrics = calc.calculate(df, "gain_pct")
    assert metrics.max_consecutive_wins == 1
    assert metrics.max_consecutive_losses == 0
```

#### 3.3-UNIT-009: streaks_single_trade_loss

```python
def test_streaks_single_trade_loss():
    """Single losing trade: (0, 1)."""
    calc = MetricsCalculator()
    df = pd.DataFrame({"gain_pct": [-5.0]})
    metrics = calc.calculate(df, "gain_pct")
    assert metrics.max_consecutive_wins == 0
    assert metrics.max_consecutive_losses == 1
```

#### 3.3-UNIT-010: max_loss_pct_none_when_no_losers

```python
def test_max_loss_pct_none_when_no_losers():
    """No losers means max_loss_pct is None."""
    calc = MetricsCalculator()
    df = pd.DataFrame({"gain_pct": [1.0, 2.0, 3.0]})
    metrics = calc.calculate(df, "gain_pct")
    assert metrics.max_loss_pct is None
```

#### 3.3-UNIT-011: chronological_sorting_affects_streaks

```python
def test_chronological_sorting_affects_streaks():
    """Unsorted data produces different streak results than sorted."""
    calc = MetricsCalculator()
    # Unsorted: shuffled order
    unsorted_df = pd.DataFrame({
        "gain_pct": [5.0, -2.0, 3.0, -4.0, 7.0],  # WLWLW pattern
        "date": ["2024-01-03", "2024-01-01", "2024-01-05", "2024-01-02", "2024-01-04"],
    })
    # Sorted would be: -2.0, -4.0, 5.0, 7.0, 3.0 (LLWWW)
    metrics_unsorted = calc.calculate(unsorted_df, "gain_pct")
    metrics_sorted = calc.calculate(unsorted_df, "gain_pct", date_col="date")
    # Streaks should differ
    assert metrics_unsorted.max_consecutive_wins != metrics_sorted.max_consecutive_wins
```

#### 3.3-UNIT-012: sorting_with_date_time_columns

```python
def test_sorting_with_date_time_columns():
    """Sort is applied when date_col and time_col provided."""
    calc = MetricsCalculator()
    df = pd.DataFrame({
        "gain_pct": [5.0, -2.0, 3.0],
        "date": ["2024-01-02", "2024-01-01", "2024-01-03"],
        "time": ["09:30", "09:30", "09:30"],
    })
    # After sorting: -2.0 (loss), 5.0 (win), 3.0 (win) = max_wins = 2
    metrics = calc.calculate(df, "gain_pct", date_col="date", time_col="time")
    assert metrics.max_consecutive_wins == 2
```

#### 3.3-UNIT-013: pre_sorted_data_unchanged

```python
def test_pre_sorted_data_unchanged():
    """Pre-sorted data produces same results with or without sort params."""
    calc = MetricsCalculator()
    df = pd.DataFrame({
        "gain_pct": [5.0, 3.0, -2.0],
        "date": ["2024-01-01", "2024-01-02", "2024-01-03"],
    })
    metrics_no_sort = calc.calculate(df, "gain_pct")
    metrics_with_sort = calc.calculate(df, "gain_pct", date_col="date")
    assert metrics_no_sort.max_consecutive_wins == metrics_with_sort.max_consecutive_wins
```

#### 3.3-UNIT-014: max_loss_pct_respects_stop_loss_adjustment

```python
def test_max_loss_pct_respects_stop_loss_adjustment():
    """Max loss capped by stop_loss when MAE exceeds stop_loss."""
    calc = MetricsCalculator()
    df = pd.DataFrame({
        "gain_pct": [5.0, -8.0, -3.0],  # -8% is worst
        "mae_pct": [1.0, 10.0, 2.0],  # -8% trade has MAE > stop_loss
    })
    params = AdjustmentParams(stop_loss=5.0, efficiency=0.0)
    metrics = calc.calculate(df, "gain_pct", mae_col="mae_pct", adjustment_params=params)
    # -8% trade should be capped to -5% (stop_loss)
    assert metrics.max_loss_pct == pytest.approx(-5.0, abs=0.01)
```

#### 3.3-UNIT-015: max_loss_pct_no_cap_when_below_stop_loss

```python
def test_max_loss_pct_no_cap_when_below_stop_loss():
    """Losses below stop_loss not affected."""
    calc = MetricsCalculator()
    df = pd.DataFrame({
        "gain_pct": [5.0, -3.0, -2.0],  # -3% is worst
        "mae_pct": [1.0, 2.0, 1.5],  # MAE < stop_loss for all
    })
    params = AdjustmentParams(stop_loss=5.0, efficiency=0.0)
    metrics = calc.calculate(df, "gain_pct", mae_col="mae_pct", adjustment_params=params)
    # No capping should occur
    assert metrics.max_loss_pct == pytest.approx(-3.0, abs=0.01)
```

### Widget Tests (tests/widget/test_metrics_grid.py)

#### 3.3-WIDG-001: metrics_grid_displays_streak_metrics

```python
def test_metrics_grid_displays_streak_metrics(qtbot):
    """Grid includes streak and max loss metric cards."""
    grid = MetricsGrid()
    qtbot.addWidget(grid)
    assert "max_consecutive_wins" in grid._cards
    assert "max_consecutive_losses" in grid._cards
    assert "max_loss_pct" in grid._cards
```

#### 3.3-WIDG-002: streak_metrics_tooltips_present

```python
def test_streak_metrics_tooltips_present(qtbot):
    """Streak metrics have tooltips."""
    grid = MetricsGrid()
    qtbot.addWidget(grid)
    assert grid._cards["max_consecutive_wins"].toolTip() != ""
    assert grid._cards["max_consecutive_losses"].toolTip() != ""
    assert grid._cards["max_loss_pct"].toolTip() != ""
```

#### 3.3-WIDG-003: max_loss_displays_coral_color

```python
def test_max_loss_displays_coral_color(qtbot):
    """Max loss (negative) displays in coral color."""
    grid = MetricsGrid()
    qtbot.addWidget(grid)
    metrics = TradingMetrics(
        num_trades=10, win_rate=50.0, avg_winner=5.0, avg_loser=-5.0,
        rr_ratio=1.0, ev=0.0, kelly=0.0,
        max_consecutive_wins=3, max_consecutive_losses=3, max_loss_pct=-6.0
    )
    grid.update_metrics(metrics)
    # Verify value is displayed (color handled by MetricCard)
    card = grid._cards["max_loss_pct"]
    assert "-6.00" in card.value_label.text() or "-6" in card.value_label.text()
```

#### 3.3-WIDG-004: streak_metrics_update_on_signal

```python
def test_streak_metrics_update_on_signal(qtbot):
    """Streak metrics update when update_metrics called."""
    grid = MetricsGrid()
    qtbot.addWidget(grid)

    metrics_v1 = TradingMetrics(..., max_consecutive_wins=2, max_consecutive_losses=1, ...)
    metrics_v2 = TradingMetrics(..., max_consecutive_wins=5, max_consecutive_losses=3, ...)

    grid.update_metrics(metrics_v1)
    grid.update_metrics(metrics_v2)

    # Verify latest values displayed
    assert "5" in grid._cards["max_consecutive_wins"].value_label.text()
```

#### 3.3-WIDG-005: debounced_recalculation

```python
def test_debounced_recalculation(qtbot):
    """Multiple rapid changes result in single recalculation."""
    # This tests the debounce timer behavior
    # Implementation depends on PnLStatsTab signal handling
```

### Integration Tests (tests/integration/)

#### 3.3-INT-001: recalculation_triggered_on_stop_loss_change

```python
def test_recalculation_triggered_on_stop_loss_change(qtbot, app_state):
    """Stop loss change triggers metrics recalculation."""
    # Setup: PnLStatsTab with baseline data
    # Action: Emit adjustment_params_changed with new stop_loss
    # Verify: MetricsCalculator.calculate() called
    # Verify: max_loss_pct reflects new stop_loss
```

#### 3.3-INT-002: metrics_update_after_adjustment_change

```python
def test_metrics_update_after_adjustment_change(qtbot, app_state):
    """MetricsGrid receives updated values after adjustment change."""
    # Setup: Full signal chain
    # Action: Change stop_loss
    # Verify: MetricsGrid.update_metrics() receives new TradingMetrics
```

## Recommended Execution Order

1. **P0 Unit tests** (fail fast on core algorithm)
   - 3.3-UNIT-001, 002, 003 (algorithm correctness)
   - 3.3-UNIT-011 (sorting dependency)
   - 3.3-UNIT-014 (stop loss integration)
   - 3.3-INT-001 (recalculation trigger)

2. **P1 Unit tests** (edge cases and integration)
   - 3.3-UNIT-004 through 007 (edge cases)
   - 3.3-UNIT-012, 015 (sorting and stop loss details)

3. **P1 Widget tests** (UI verification)
   - 3.3-WIDG-001, 002, 003

4. **P1 Integration test**
   - 3.3-INT-002

5. **P2 tests** (nice-to-have coverage)
   - Remaining unit and widget tests

## Test Fixture Requirements

### streak_test_df Fixture

```python
@pytest.fixture
def streak_test_df():
    """DataFrame with known streak patterns from story sample data."""
    return pd.DataFrame({
        "gain_pct": [5.0, 3.0, 7.0, -2.0, -4.0, 8.0, -6.0, -3.0, -5.0, 2.0],
        "mae_pct": [1.0] * 10,
    })
```

Expected results:
- Max Consecutive Wins: 3 (trades 1-3)
- Max Consecutive Losses: 3 (trades 7-9)
- Max Loss %: -6.0% (trade 7)

## Quality Checklist

- [x] Every AC has test coverage
- [x] Test levels are appropriate (unit for logic, widget for UI, integration for signal flow)
- [x] No duplicate coverage across levels
- [x] Critical paths have multiple levels (stop loss: unit + integration)
- [x] Risk mitigations are addressed
- [x] Priorities align with business risk
- [x] Test IDs follow naming convention
- [x] Scenarios are atomic and independent

---

## Gate YAML Block

```yaml
test_design:
  scenarios_total: 22
  by_level:
    unit: 15
    widget: 5
    integration: 2
    e2e: 0
  by_priority:
    p0: 6
    p1: 10
    p2: 6
  coverage_gaps: []
```

---

Test design matrix: docs/qa/assessments/3.3-test-design-20260111.md
P0 tests identified: 6
