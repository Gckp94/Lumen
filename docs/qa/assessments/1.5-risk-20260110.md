# Risk Profile: Story 1.5 - First Trigger Baseline

Date: 2026-01-10
Reviewer: Quinn (Test Architect)

## Executive Summary

- Total Risks Identified: 7
- Critical Risks: 0
- High Risks: 1
- Medium Risks: 3
- Low Risks: 3
- Risk Score: 73/100 (Moderate Risk)

## Risk Matrix

| Risk ID   | Description                              | Probability | Impact     | Score | Priority |
|-----------|------------------------------------------|-------------|------------|-------|----------|
| PERF-001  | First trigger exceeds 500ms on 100k rows | Medium (2)  | High (3)   | 6     | High     |
| DATA-001  | Null/NaT time handling inconsistency     | Medium (2)  | Medium (2) | 4     | Medium   |
| TECH-001  | AppState signal race conditions          | Low (1)     | High (3)   | 3     | Low      |
| TECH-002  | Qt signal memory leaks                   | Low (1)     | High (3)   | 3     | Low      |
| DATA-002  | Duplicate time resolution ambiguity      | Medium (2)  | Low (1)    | 2     | Low      |
| TECH-003  | Circular dependency in component wiring  | Low (1)     | Medium (2) | 2     | Low      |
| OPS-001   | TradingMetrics/FilterCriteria not exist  | Medium (2)  | Medium (2) | 4     | Medium   |

## Critical Risks Requiring Immediate Attention

*No critical risks identified (score 9)*

## High Risks (Score 6)

### PERF-001: First Trigger Algorithm Performance

**Score: 6 (High)**
**Probability**: Medium - Pandas groupby with sort operations can be slow on large datasets; depends heavily on data cardinality and implementation
**Impact**: High - AC6 mandates < 500ms for 100k rows; failing this is a blocking acceptance criterion

**Affected Components:**
- `FirstTriggerEngine.apply()`
- `DataInputTab` data flow

**Mitigation:**
- Use vectorized pandas operations (`sort_values` + `drop_duplicates`)
- Avoid Python loops over rows
- Profile with `pytest.mark.slow` performance test
- Consider caching if repeated operations needed

**Testing Requirements:**
- Performance test with 100k synthetic rows
- Test with varying cardinality (50 tickers Ã— 250 dates = 12,500 groups)
- Memory profiling to ensure no excessive allocations

**Residual Risk**: Low - pandas vectorized operations are well-optimized

## Medium Risks (Score 4)

### DATA-001: Null/NaT Time Handling Inconsistency

**Score: 4 (Medium)**
**Probability**: Medium - Real trading data often has missing time values
**Impact**: Medium - Incorrect first trigger selection could affect analysis accuracy

**Affected Components:**
- `FirstTriggerEngine.apply()`
- Sort behavior with `na_position="first"`

**Mitigation:**
- Explicit `na_position="first"` in `sort_values()`
- Unit tests with null time scenarios
- Document behavior in Dev Notes
- Log warning when null times encountered

**Testing Requirements:**
- Test with None, NaT, and pd.NaT values
- Test mixed null and valid times in same ticker-date group

**Residual Risk**: Low - behavior is well-defined once tested

### OPS-001: Forward References to Non-Existent Classes

**Score: 4 (Medium)**
**Probability**: Medium - Story 1.6 creates TradingMetrics and FilterCriteria
**Impact**: Medium - Type hints may cause import errors or mypy failures

**Affected Components:**
- `AppState` class signal type hints
- `baseline_metrics`, `filtered_metrics` properties

**Mitigation:**
- Use `object` type hints initially (as noted in Dev Notes)
- Use `TYPE_CHECKING` guard for forward references
- Document dependency on Story 1.6 for full typing

**Testing Requirements:**
- Verify `make typecheck` passes
- Test AppState without TradingMetrics

**Residual Risk**: Low - well-documented workaround

## Low Risks (Score 2-3)

### TECH-001: AppState Signal Race Conditions

**Score: 3 (Low)**
**Probability**: Low - PyQt6 signals are queued by default
**Impact**: High - Race conditions could cause data inconsistency

**Affected Components:**
- `AppState` signal emissions
- Cross-tab communication

**Mitigation:**
- Use Qt signal/slot mechanism correctly
- Emit signals after state updates complete
- Add signal spy tests with qtbot

**Testing Requirements:**
- Test signal order with qtbot.waitSignal()
- Test rapid signal emissions

### TECH-002: Qt Signal Memory Leaks

**Score: 3 (Low)**
**Probability**: Low - Standard PyQt6 usage pattern
**Impact**: High - Memory leak would cause application degradation

**Affected Components:**
- `AppState` as long-lived QObject
- Signal connections from tabs

**Mitigation:**
- Ensure proper parent-child relationships
- Use deleteLater() if needed
- Profile memory in performance tests

**Testing Requirements:**
- Memory profiling with tracemalloc
- Check for lingering references

### DATA-002: Duplicate Time Resolution Ambiguity

**Score: 2 (Low)**
**Probability**: Medium - Duplicate times are possible in trading data
**Impact**: Low - First occurrence is kept; behavior is deterministic

**Affected Components:**
- `FirstTriggerEngine.apply()`
- `drop_duplicates(keep="first")`

**Mitigation:**
- Document that original DataFrame order determines winner
- Add unit test for duplicate time scenario

**Testing Requirements:**
- Test duplicate times keep first occurrence

### TECH-003: Circular Dependency in Component Wiring

**Score: 2 (Low)**
**Probability**: Low - Simple hierarchical design
**Impact**: Medium - Import errors would block application startup

**Affected Components:**
- `main.py` / `MainWindow`
- Tab initialization with AppState

**Mitigation:**
- Pass AppState as constructor argument (not import)
- Keep core classes independent

**Testing Requirements:**
- Integration test of full startup sequence

## Risk Distribution

### By Category

- Technical (TECH): 3 risks (0 critical, 0 high)
- Performance (PERF): 1 risk (0 critical, 1 high)
- Data (DATA): 2 risks (0 critical, 0 high)
- Operational (OPS): 1 risk (0 critical, 0 high)

### By Component

- FirstTriggerEngine: 3 risks (PERF-001, DATA-001, DATA-002)
- AppState: 3 risks (TECH-001, TECH-002, OPS-001)
- Integration/Wiring: 1 risk (TECH-003)

## Risk-Based Testing Strategy

### Priority 1: High Risk Tests

1. **Performance test** - 100k rows < 500ms (PERF-001)
2. **Null time handling** - Sort nulls first (DATA-001)

### Priority 2: Medium Risk Tests

3. **Type checking passes** - mypy with forward refs (OPS-001)
4. **Signal emissions** - Correct order and data (TECH-001)

### Priority 3: Low Risk Tests

5. **Duplicate time behavior** - First wins (DATA-002)
6. **Memory profiling** - No leaks (TECH-002)
7. **Import test** - No circular deps (TECH-003)

## Risk Acceptance Criteria

### Must Fix Before Production

- PERF-001 must pass < 500ms requirement
- DATA-001 null handling must be deterministic

### Can Deploy with Mitigation

- OPS-001 with `object` type hints (full typing in Story 1.6)
- TECH-001, TECH-002, TECH-003 with monitoring

### Accepted Risks

- DATA-002: Documented behavior, deterministic outcome

## Monitoring Requirements

Post-deployment monitoring for:

- **Performance**: Log first trigger execution time
- **Data Quality**: Log count of null times encountered
- **Memory**: Monitor process memory over time

## Risk Review Triggers

Review and update risk profile when:

- Performance issues reported on large files
- Data quality issues with null handling
- Memory growth observed
- Story 1.6 (TradingMetrics) is implemented
