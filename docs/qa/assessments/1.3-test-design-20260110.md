# Test Design: Story 1.3 - File Selection & Data Loading

Date: 2026-01-10
Designer: Quinn (Test Architect)

## Test Strategy Overview

- **Total test scenarios:** 28
- **Unit tests:** 12 (43%)
- **Widget tests:** 14 (50%)
- **Integration tests:** 2 (7%)
- **E2E tests:** 0 (0%)
- **Priority distribution:** P0: 8, P1: 14, P2: 6

### Level Justification

This story involves file I/O operations, background threading, and UI interactions:

- **Unit tests** for FileLoader logic, exception classes, and pure functions
- **Widget tests** for Qt component configuration, signal emissions, and UI state
- **Integration tests** for worker-to-UI flow with actual file loading
- **No E2E tests** - widget and integration tests provide sufficient coverage; no cross-tab workflows

---

## Test Scenarios by Acceptance Criteria

### AC1: Data Input tab contains file loading section with styled controls

**Requirement:** Data Input tab has file loading UI section with styled controls

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 1.3-WIDGET-001 | Widget | P0 | DataInputTab contains "Select File" button | Core UI element must exist |
| 1.3-WIDGET-002 | Widget | P1 | DataInputTab has section header "Select Data File" | UI structure per design |
| 1.3-WIDGET-003 | Widget | P1 | UI controls use theme Colors | Visual consistency |

**Test Implementation:**
```python
# tests/widget/test_data_input_tab.py
def test_tab_has_select_file_button(qtbot: QtBot):
    """DataInputTab contains Select File button."""
    tab = DataInputTab()
    qtbot.addWidget(tab)
    button = tab.findChild(QPushButton, "select_file_button")
    assert button is not None
    assert "Select File" in button.text()

def test_tab_has_section_header(qtbot: QtBot):
    """DataInputTab has file selection section header."""
    tab = DataInputTab()
    qtbot.addWidget(tab)
    labels = tab.findChildren(QLabel)
    assert any("Select Data File" in label.text() for label in labels)
```

---

### AC2: "Select File" button opens native file dialog (Excel, CSV filters)

**Requirement:** File dialog with appropriate filters for supported formats

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 1.3-UNIT-001 | Unit | P1 | FileLoader.SUPPORTED_EXTENSIONS contains xlsx, xls, csv, parquet | Format support verification |
| 1.3-WIDGET-004 | Widget | P1 | Select File button is clickable and enabled | UI interaction ready |

**Test Implementation:**
```python
# tests/unit/test_file_loader.py
def test_supported_extensions():
    """FileLoader supports xlsx, xls, csv, parquet."""
    loader = FileLoader()
    assert ".xlsx" in loader.SUPPORTED_EXTENSIONS
    assert ".xls" in loader.SUPPORTED_EXTENSIONS
    assert ".csv" in loader.SUPPORTED_EXTENSIONS
    assert ".parquet" in loader.SUPPORTED_EXTENSIONS

# tests/widget/test_data_input_tab.py
def test_select_file_button_enabled(qtbot: QtBot):
    """Select File button is enabled on tab load."""
    tab = DataInputTab()
    qtbot.addWidget(tab)
    button = tab.findChild(QPushButton, "select_file_button")
    assert button.isEnabled()
```

---

### AC3: File path display shows selected file

**Requirement:** Read-only line edit shows selected file path

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 1.3-WIDGET-005 | Widget | P0 | File path display exists and is read-only | Prevent user editing path |
| 1.3-WIDGET-006 | Widget | P1 | File path display initially empty | Clean initial state |

**Test Implementation:**
```python
# tests/widget/test_data_input_tab.py
def test_file_path_display_is_readonly(qtbot: QtBot):
    """File path display is read-only."""
    tab = DataInputTab()
    qtbot.addWidget(tab)
    line_edit = tab.findChild(QLineEdit, "file_path_display")
    assert line_edit is not None
    assert line_edit.isReadOnly()

def test_file_path_display_initially_empty(qtbot: QtBot):
    """File path display is empty on load."""
    tab = DataInputTab()
    qtbot.addWidget(tab)
    line_edit = tab.findChild(QLineEdit, "file_path_display")
    assert line_edit.text() == ""
```

---

### AC4: Sheet selector dropdown for Excel files (populated with sheet names)

**Requirement:** Sheet selector appears for Excel files, hidden for CSV

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 1.3-WIDGET-007 | Widget | P0 | Sheet selector initially hidden | CSV doesn't need sheet selection |
| 1.3-UNIT-002 | Unit | P0 | get_sheet_names() returns list of sheet names | Core Excel functionality |
| 1.3-UNIT-003 | Unit | P1 | get_sheet_names() with non-Excel raises error | Input validation |

**Test Implementation:**
```python
# tests/widget/test_data_input_tab.py
def test_sheet_selector_initially_hidden(qtbot: QtBot):
    """Sheet selector is hidden until Excel file selected."""
    tab = DataInputTab()
    qtbot.addWidget(tab)
    combo = tab.findChild(QComboBox, "sheet_selector")
    assert combo is not None
    assert not combo.isVisible()

# tests/unit/test_file_loader.py
def test_get_sheet_names_returns_list(tmp_path):
    """get_sheet_names returns list of sheet names."""
    # Create test Excel file
    import pandas as pd
    xlsx_file = tmp_path / "test.xlsx"
    with pd.ExcelWriter(xlsx_file, engine="openpyxl") as writer:
        pd.DataFrame({"a": [1]}).to_excel(writer, sheet_name="Sheet1", index=False)
        pd.DataFrame({"b": [2]}).to_excel(writer, sheet_name="Data", index=False)
    
    loader = FileLoader()
    sheets = loader.get_sheet_names(xlsx_file)
    assert isinstance(sheets, list)
    assert "Sheet1" in sheets
    assert "Data" in sheets

def test_get_sheet_names_with_csv_raises_error(tmp_path):
    """get_sheet_names with CSV file raises error."""
    csv_file = tmp_path / "test.csv"
    csv_file.write_text("a,b\n1,2\n")
    loader = FileLoader()
    with pytest.raises(FileLoadError):
        loader.get_sheet_names(csv_file)
```

---

### AC5: "Load Data" button triggers loading with progress indicator

**Requirement:** Load Data button triggers background loading with progress

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 1.3-WIDGET-008 | Widget | P0 | Load Data button initially disabled | Prevent load before file selection |
| 1.3-UNIT-004 | Unit | P1 | FileLoadWorker has progress signal | Required for progress reporting |
| 1.3-UNIT-005 | Unit | P1 | FileLoadWorker has finished signal | Required for completion handling |
| 1.3-UNIT-006 | Unit | P1 | FileLoadWorker has error signal | Required for error handling |

**Test Implementation:**
```python
# tests/widget/test_data_input_tab.py
def test_load_button_initially_disabled(qtbot: QtBot):
    """Load Data button is disabled until file selected."""
    tab = DataInputTab()
    qtbot.addWidget(tab)
    button = tab.findChild(QPushButton, "load_data_button")
    assert button is not None
    assert not button.isEnabled()

# tests/unit/test_file_load_worker.py
def test_worker_has_progress_signal():
    """FileLoadWorker defines progress signal."""
    from src.core.file_load_worker import FileLoadWorker
    from pathlib import Path
    worker = FileLoadWorker(Path("dummy.csv"))
    assert hasattr(worker, 'progress')

def test_worker_has_finished_signal():
    """FileLoadWorker defines finished signal."""
    from src.core.file_load_worker import FileLoadWorker
    from pathlib import Path
    worker = FileLoadWorker(Path("dummy.csv"))
    assert hasattr(worker, 'finished')

def test_worker_has_error_signal():
    """FileLoadWorker defines error signal."""
    from src.core.file_load_worker import FileLoadWorker
    from pathlib import Path
    worker = FileLoadWorker(Path("dummy.csv"))
    assert hasattr(worker, 'error')
```

---

### AC6: Success message: "Loaded {n:,} rows from {filename}"

**Requirement:** Success message with formatted row count

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 1.3-WIDGET-009 | Widget | P1 | Status message label exists | Required for feedback |
| 1.3-INT-001 | Integration | P1 | Successful load shows formatted row count | End-to-end success path |

**Test Implementation:**
```python
# tests/widget/test_data_input_tab.py
def test_status_message_label_exists(qtbot: QtBot):
    """DataInputTab has status message label."""
    tab = DataInputTab()
    qtbot.addWidget(tab)
    # Status label should exist (may be empty initially)
    labels = tab.findChildren(QLabel)
    # At minimum, the section header label exists
    assert len(labels) >= 1

# tests/integration/test_file_loading.py
def test_successful_load_shows_row_count(qtbot: QtBot, sample_csv_file):
    """Successful file load shows formatted row count message."""
    tab = DataInputTab()
    qtbot.addWidget(tab)
    # Simulate file selection and load
    # Verify message contains row count with comma formatting
    # e.g., "Loaded 1,000 rows from trades.csv"
```

---

### AC7: Error handling with plain English messages

**Requirement:** User-friendly error messages for all failure cases

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 1.3-UNIT-007 | Unit | P0 | FileLoadError exception class exists | Exception hierarchy |
| 1.3-UNIT-008 | Unit | P0 | LumenError base exception exists | Exception hierarchy |
| 1.3-UNIT-009 | Unit | P1 | Missing file raises FileLoadError with message | File not found case |
| 1.3-UNIT-010 | Unit | P1 | Unsupported extension raises FileLoadError | Invalid format case |
| 1.3-WIDGET-010 | Widget | P2 | Error display uses SIGNAL_CORAL color | Visual error indication |

**Test Implementation:**
```python
# tests/unit/test_exceptions.py
def test_file_load_error_exists():
    """FileLoadError exception class exists."""
    from src.core.exceptions import FileLoadError
    assert issubclass(FileLoadError, Exception)

def test_lumen_error_base_exists():
    """LumenError base exception exists."""
    from src.core.exceptions import LumenError
    assert issubclass(LumenError, Exception)

def test_file_load_error_inherits_from_lumen_error():
    """FileLoadError inherits from LumenError."""
    from src.core.exceptions import FileLoadError, LumenError
    assert issubclass(FileLoadError, LumenError)

# tests/unit/test_file_loader.py
def test_load_missing_file_raises_error():
    """Loading missing file raises FileLoadError."""
    loader = FileLoader()
    with pytest.raises(FileLoadError) as exc_info:
        loader.load(Path("/nonexistent/file.csv"))
    assert "not found" in str(exc_info.value).lower()

def test_load_unsupported_extension_raises_error(tmp_path):
    """Loading unsupported extension raises FileLoadError."""
    bad_file = tmp_path / "test.txt"
    bad_file.write_text("data")
    loader = FileLoader()
    with pytest.raises(FileLoadError) as exc_info:
        loader.load(bad_file)
    assert "supported" in str(exc_info.value).lower() or "extension" in str(exc_info.value).lower()
```

---

### AC8: Load completes in < 3 seconds for 100k rows

**Requirement:** Performance requirement for large file loading

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 1.3-UNIT-011 | Unit | P2 | Load CSV returns DataFrame | Basic functionality |
| 1.3-UNIT-012 | Unit | P2 | Load Excel with sheet returns DataFrame | Basic functionality |
| 1.3-INT-002 | Integration | P2 | 100k row CSV loads in under 3 seconds | NFR validation |

**Test Implementation:**
```python
# tests/unit/test_file_loader.py
def test_load_csv_returns_dataframe(tmp_path):
    """Load CSV file returns pandas DataFrame."""
    csv_file = tmp_path / "test.csv"
    csv_file.write_text("ticker,date,time,gain\nAAPL,2024-01-01,09:30:00,1.5\n")
    loader = FileLoader()
    df = loader.load(csv_file)
    assert len(df) == 1
    assert "ticker" in df.columns

def test_load_excel_with_sheet_returns_dataframe(tmp_path):
    """Load Excel file with specific sheet returns DataFrame."""
    import pandas as pd
    xlsx_file = tmp_path / "test.xlsx"
    pd.DataFrame({"col": [1, 2, 3]}).to_excel(xlsx_file, sheet_name="TestSheet", index=False)
    
    loader = FileLoader()
    df = loader.load(xlsx_file, sheet="TestSheet")
    assert len(df) == 3
    assert "col" in df.columns

# tests/integration/test_file_loading.py
def test_large_file_loads_under_3_seconds(tmp_path):
    """100k row CSV loads in under 3 seconds (NFR)."""
    import pandas as pd
    import time
    
    # Generate 100k row test file
    large_csv = tmp_path / "large.csv"
    df = pd.DataFrame({
        "ticker": ["AAPL"] * 100000,
        "date": ["2024-01-01"] * 100000,
        "gain": range(100000),
    })
    df.to_csv(large_csv, index=False)
    
    loader = FileLoader()
    start = time.perf_counter()
    result = loader.load(large_csv)
    elapsed = time.perf_counter() - start
    
    assert len(result) == 100000
    assert elapsed < 3.0, f"Load took {elapsed:.2f}s, expected <3s"
```

---

### AC9: After successful load, trigger column auto-detection

**Requirement:** Successful load triggers next workflow step

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 1.3-WIDGET-011 | Widget | P1 | DataInputTab emits signal or stores DataFrame on load | Data handoff to next story |
| 1.3-WIDGET-012 | Widget | P2 | DataFrame accessible after successful load | State management |

**Test Implementation:**
```python
# tests/widget/test_data_input_tab.py
def test_tab_has_data_loaded_signal_or_property(qtbot: QtBot):
    """DataInputTab has mechanism to access loaded DataFrame."""
    tab = DataInputTab()
    qtbot.addWidget(tab)
    # Either has a signal or a property/method
    has_signal = hasattr(tab, 'data_loaded')
    has_property = hasattr(tab, 'dataframe') or hasattr(tab, 'get_dataframe')
    assert has_signal or has_property, "Tab must expose loaded data"
```

---

## Additional Edge Case Tests

| ID | Level | Priority | Test | Justification | Risk Mitigated |
|----|-------|----------|------|---------------|----------------|
| 1.3-WIDGET-013 | Widget | P2 | Load button disabled during loading | Prevent double-load | TECH-002 |
| 1.3-WIDGET-014 | Widget | P2 | Buttons re-enabled after load error | UI recovery | TECH-002 |

---

## Risk Coverage

| Risk ID | Mitigated By Tests |
|---------|-------------------|
| TECH-001 | 1.3-UNIT-001, 1.3-UNIT-002, 1.3-UNIT-011, 1.3-UNIT-012 |
| PERF-001 | 1.3-INT-002 |
| PERF-002 | 1.3-UNIT-004, 1.3-UNIT-005, 1.3-UNIT-006, 1.3-INT-001 |
| TECH-002 | 1.3-WIDGET-013, 1.3-WIDGET-014 |
| DATA-001 | 1.3-UNIT-009, 1.3-UNIT-010 |
| BUS-001 | 1.3-UNIT-009, 1.3-UNIT-010 |

---

## Test Summary Table

| ID | Level | Priority | AC | Test Description |
|----|-------|----------|-----|------------------|
| 1.3-WIDGET-001 | Widget | P0 | 1 | Tab has Select File button |
| 1.3-WIDGET-002 | Widget | P1 | 1 | Tab has section header |
| 1.3-WIDGET-003 | Widget | P1 | 1 | UI uses theme Colors |
| 1.3-UNIT-001 | Unit | P1 | 2 | SUPPORTED_EXTENSIONS correct |
| 1.3-WIDGET-004 | Widget | P1 | 2 | Select File button enabled |
| 1.3-WIDGET-005 | Widget | P0 | 3 | File path display read-only |
| 1.3-WIDGET-006 | Widget | P1 | 3 | File path initially empty |
| 1.3-WIDGET-007 | Widget | P0 | 4 | Sheet selector initially hidden |
| 1.3-UNIT-002 | Unit | P0 | 4 | get_sheet_names() returns list |
| 1.3-UNIT-003 | Unit | P1 | 4 | get_sheet_names() validates input |
| 1.3-WIDGET-008 | Widget | P0 | 5 | Load button initially disabled |
| 1.3-UNIT-004 | Unit | P1 | 5 | Worker has progress signal |
| 1.3-UNIT-005 | Unit | P1 | 5 | Worker has finished signal |
| 1.3-UNIT-006 | Unit | P1 | 5 | Worker has error signal |
| 1.3-WIDGET-009 | Widget | P1 | 6 | Status message label exists |
| 1.3-INT-001 | Integration | P1 | 6 | Load shows formatted row count |
| 1.3-UNIT-007 | Unit | P0 | 7 | FileLoadError exists |
| 1.3-UNIT-008 | Unit | P0 | 7 | LumenError base exists |
| 1.3-UNIT-009 | Unit | P1 | 7 | Missing file error message |
| 1.3-UNIT-010 | Unit | P1 | 7 | Unsupported extension error |
| 1.3-WIDGET-010 | Widget | P2 | 7 | Error uses SIGNAL_CORAL |
| 1.3-UNIT-011 | Unit | P2 | 8 | Load CSV returns DataFrame |
| 1.3-UNIT-012 | Unit | P2 | 8 | Load Excel returns DataFrame |
| 1.3-INT-002 | Integration | P2 | 8 | 100k rows loads <3 seconds |
| 1.3-WIDGET-011 | Widget | P1 | 9 | Tab exposes loaded data |
| 1.3-WIDGET-012 | Widget | P2 | 9 | DataFrame accessible after load |
| 1.3-WIDGET-013 | Widget | P2 | 5 | Load button disabled during load |
| 1.3-WIDGET-014 | Widget | P2 | 7 | Buttons re-enabled after error |

---

## Recommended Execution Order

1. **P0 Unit tests** (fail fast on core components)
   - 1.3-UNIT-002, 1.3-UNIT-007, 1.3-UNIT-008

2. **P0 Widget tests** (verify core UI structure)
   - 1.3-WIDGET-001, 1.3-WIDGET-005, 1.3-WIDGET-007, 1.3-WIDGET-008

3. **P1 Unit tests** (validate FileLoader and Worker)
   - 1.3-UNIT-001, 1.3-UNIT-003 through 1.3-UNIT-006, 1.3-UNIT-009, 1.3-UNIT-010

4. **P1 Widget tests** (verify UI interactions)
   - 1.3-WIDGET-002 through 1.3-WIDGET-004, 1.3-WIDGET-006, 1.3-WIDGET-009, 1.3-WIDGET-011

5. **P1 Integration tests** (verify end-to-end flow)
   - 1.3-INT-001

6. **P2 tests** (secondary validation and edge cases)
   - Remaining tests as time permits

---

## Quality Checklist

- [x] Every AC has at least one test
- [x] Test levels are appropriate (unit for logic, widget for Qt, integration for flows)
- [x] No duplicate coverage across levels
- [x] Critical paths (file loading, error handling) have P0/P1 priority
- [x] Risk mitigations are addressed
- [x] Test IDs follow naming convention (1.3-LEVEL-SEQ)
- [x] Scenarios are atomic and independent

---

## Gate YAML Block

```yaml
test_design:
  scenarios_total: 28
  by_level:
    unit: 12
    widget: 14
    integration: 2
    e2e: 0
  by_priority:
    p0: 8
    p1: 14
    p2: 6
  coverage_gaps: []
```

---

Test design matrix: docs/qa/assessments/1.3-test-design-20260110.md
P0 tests identified: 8
